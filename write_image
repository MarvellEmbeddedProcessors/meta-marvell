#!/bin/sh
#
# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# Modified by Adam Lussier <adam.lussier@timesys.com>
#
# This attempts to guide linux users through the process of putting a rootfs
# image onto a removable USB drive.
#
# We may not need root privileges if we have the right permissions.
#
set -eu

##############################################################################
# Configuration goes here

# Where should we do our work? Use 'WORKDIR=' to make a temporary directory,
# but using a persistent location may let us resume interrupted downloads or
# run again without needing to download a second time.
WORKDIR=${WORKDIR:-/tmp/tmp.crosrec}


##############################################################################
# Some temporary filenames
debug='debug.log'
tmpfile='tmp.txt'

##############################################################################
# Various warning messages

DEBUG() {
  echo "DEBUG: $@" >>"$debug"
}

prompt() {
  # builtin echo may not grok '-n'. We should always have /bin/echo, right?
  /bin/echo -n "$@"
}

warn() {
  echo "$@" 1>&2
}

quit() {
  warn "quitting..."
  exit 1
}

fatal() {
  warn "ERROR: $@"
  exit 1
}

ufatal() {
  warn "
ERROR: $@

You may need to run this program as a different user:
$ sudo ./write_image.sh path/to/image.bin

If that doesn't help, try using a different computer,
or ask a knowledgeable friend for help.

"
  exit 1
}

##############################################################################
# Identify the external utilities that we MUST have available.
#
# I'd like to keep the set of external *NIX commands to an absolute minimum,
# but I have to balance that against producing mysterious errors because the
# shell can't always do everything. Let's make sure that these utilities are
# all in our $PATH, or die with an error.
#
# This also sets the following global variables to select alternative utilities
# when there is more than one equivalent tool available:
#
#   FETCH          = name of utility used to download files from the web
#   CHECK          = command to invoke to generate checksums on a file
#   CHECKTYPE      = type of checksum generated
#
require_utils() {
  local extern
  local errors
  local tool
  local tmp

  extern='awk bc cat cut dd grep ls mkdir mount parted partprobe readlink sed sync umount unzip wc'
  if [ -z "$WORKDIR" ]; then
    extern="$extern mktemp"
  fi
  errors=

  for tool in $extern ; do
    if ! type "$tool" >/dev/null 2>&1 ; then
      warn "ERROR: need \"$tool\""
      errors=yes
    fi
  done

  if [ -n "$errors" ]; then
    ufatal "Some required utilities are missing."
  fi
}

##############################################################################
# Helper functions to handle the config file and image zipfile.

# Convert bytes to MB, rounding up to determine storage needed to hold bytes.
roundup() {
  local num=$1
  local div=$(( 1024 * 1024 ))
  local rem=$(( $num % $div ))

  if [ $rem -ne 0 ]; then
    num=$(($num + $div - $rem))
  fi
  echo $(( $num / $div ))
}

# Die unless the filesystem containing the current directory has enough free
# space. The argument is the number of MB required.
verify_tmp_space() {
  local need
  local got
  need="$1"

  # The output of "df -m ." could take two forms:
  #
  # Filesystem           1M-blocks      Used Available Use% Mounted on
  # /some/really/long/path/to/some/where
  #                          37546     11118     24521  32% /
  #
  # Filesystem         1048576-blocks      Used Available Capacity Mounted on
  # /some/short/path         37546     11118     24521      32% /
  #
  got=$(df -m . | awk '/^\/[^ ]+ +[0-9]/ {print $4} /^ +[0-9]/ {print $3}')

  if [ "$need" -gt "$got" ]; then
    fatal " There is not enough free space in ${WORKDIR}" \
"(it has ${got}MB, we need ${need}MB).

Please free up some space on that filesystem, or specify a temporary directory
on the commandline like so:

  WORKDIR=/path/to/some/dir  $0
"
  fi
}

##############################################################################
# Helper functions to manage USB drives.

# Return a list of base device names ("sda sdb ...") for all USB drives
get_devlist() {
  local dev
  local t
  local r

  for dev in $(cat /proc/partitions); do
    [ -r "/sys/block/$dev/device/type" ] &&
    t=$(cat "/sys/block/$dev/device/type") &&
    [ "$t" = "0" ] &&
    r=$(cat "/sys/block/$dev/removable") &&
    [ "$r" = "1" -o "$show_non_removable" = "yes" ] &&
    echo "$dev" || true
  done
}

# Return the raw size in MB of each provided base device name ("sda sdb ...")
get_devsize() {
  local dev
  local bytes
  local sectors

  for dev in $1; do
    sectors=$(cat "/sys/block/$dev/size")
    echo $(( $sectors * 512 / 1024 / 1024 ))
  done
}

# Return descriptions for each provided base device name ("sda sdb ...")
get_devinfo() {
  local dev
  local v
  local m
  local s
  local ss

  for dev in $1; do
    v=$(cat "/sys/block/$dev/device/vendor") &&
    m=$(cat "/sys/block/$dev/device/model") &&
    s=$(cat "/sys/block/$dev/size") && ss=$(echo "scale=2; $s * 512 / 1000000000" | bc) &&
    echo "/dev/$dev ${ss}GB $v $m"
  done
}

# Enumerate and descript the specified base device names ("sda sdb ...")
get_choices() {
  local dev
  local desc
  local count

  count=1
  echo "0 - <quit>"
  for dev in $1; do
    desc=$(get_devinfo "$dev")
    echo ""
    echo "$count - Use $desc"
    count=$(( count + 1 ))
  done
}

# Make the user pick a USB drive to write to. On success, it sets the global
# variable 'user_choice' to the selected device name ("sda", "sdb", etc.)
choose_drive() {
  local show
  local devlist
  local choices
  local num_drives
  local msg
  local num

  show_non_removable=no
  show=yes
  while true; do
    if [ -n "$show" ]; then
      devlist=$(get_devlist)
      choices=$(get_choices "$devlist")
      if [ -z "$devlist" ]; then
        num_drives="0"
        msg="I can't seem to find a valid USB drive."
      else
        num_drives=$(echo "$devlist" | wc -l)
        if [ "$num_drives" != "1" ]; then
          msg="I found $num_drives storage devices."
        else
          msg="I found $num_drives storage device."
        fi
      fi
      echo "

$msg  We need one with at least ${disk_needed}MB capacity.

$choices

"
    fi
    if [ "$show_non_removable" != yes ]; then
      echo "Enter 'Show non-removable media' to show all storage devices."
      echo "This will show all storage devices, including your hard drive."
      prompt "This may be required for devices that incorrectly enumerate as fixed storage."
    fi
prompt "

Enter a choice (or just press enter to scan again) [0 - $num_drives]: "
    read num
    if [ -z "$num" ] || [ "$num" = "?" ]; then
      show=yes
    elif [ "$num" = "Show non-removable media" ]; then
        show_non_removable=yes
        show=yes
        prompt "
WARNING: This will include ALL storage devices,
including your desktop's hard drive.
Press any key to confirm.
"
        read
    elif echo "$num" | grep -q '[^0-9]'; then
      echo "Sorry, I didn't understand that."
    else
      if [ "$num" -lt "0" ] || [ "$num" -gt "$num_drives" ]; then
        echo "That's not one of the choices."
      elif [ "$num" -eq 0 ]; then
        quit
      else
        break;
      fi
    fi
  done

  # global
  user_choice=$(echo $devlist | cut -d' ' -f$num)
}

# Unmount a partition
unmount_partition() {
  umount "$1" || ufatal "Unable to unmount $1."
}

##############################################################################
# Okay, do something...

# Make sure we have the tools we need
require_utils

if [ "$#" -ne 1 ]; then
  prompt \
"Usage: sudo ./write_image.sh IMAGE
Write an image file to a USB key or SD card for use in a
Marvell Armada38x board.

IMAGE specifies the path to the image you want to write, such as:

  sudo ./write_image build/tmp/deploy/images/armada38x-db/core-image-base-armada38x.tar.bz2
"
  quit
fi

image_file=$(readlink -f "$1")

if [ -n "${2-}" ]; then
	user_choice=$(readlink -f "$2")
fi
disk_needed=$(roundup $(ls -l "$image_file" | awk '{print $5}'))

# Need a place to work. We prefer a fixed location so we can try to resume any
# interrupted downloads.
if [ -n "$WORKDIR" ]; then
  if [ ! -d "$WORKDIR" ] && ! mkdir "$WORKDIR" ; then
    warn "Using temporary directory"
    WORKDIR=
  fi
fi
if [ -z "$WORKDIR" ]; then
  WORKDIR=$(mktemp -d)
  # Clean up temporary directory afterwards
  trap "cd; rm -rf ${WORKDIR}" EXIT
fi

cd "$WORKDIR"
warn "Working in $WORKDIR/"
rm -f "$debug"

# Make the user pick a USB drive, or exit.
choose_drive

# Be sure
dev_desc=$(get_devinfo "$user_choice")

# Start asking for confirmation
dev_size=$(get_devsize "$user_choice")
if [ "$dev_size" -lt "$disk_needed" ]; then
  echo "

WARNING: This drive seems too small (${dev_size}MB)." \
  "The image is ${disk_needed}MB."
fi
echo "
Is this the device you want to put the image on?

  $dev_desc
"
prompt "You must enter 'YES' (all uppercase) to continue: "
read tmp
if [ "$tmp" != "YES" ]; then
  quit
fi

# Be very sure
echo "

I'm really going to erase this device. This will permanently ERASE
whatever you may have on that drive. You won't be able to undo it.

  $dev_desc
"

prompt "If you're sure that's correct, enter 'DoIt' now (case is important): "
read tmp
if [ "$tmp" != "DoIt" ]; then
  quit
fi
echo "

Installing the image

"

# Unmount anything on that device.
echo "unmounting..."
for tmp in $(mount | grep ^"/dev/${user_choice}" | cut -d' ' -f1); do
  unmount_partition "$tmp"
done

# Write it.
echo "copying... (this may take several minutes)"

# Create partition table
parted -a optimal -s /dev/${user_choice} mklabel msdos
parted -a optimal -s /dev/${user_choice} mkpart primary ext2 0% 100%
partprobe
parted /dev/${user_choice} print

mkdir -p ${WORKDIR}/mnt
if [ -e /dev/${user_choice}1 ]; then
  user_part="/dev/${user_choice}1"
elif [ -e /dev/${user_choice}p1 ]; then
  user_part="/dev/${user_choice}p1"
fi

mkfs.ext2 ${user_part}
mount ${user_part} ${WORKDIR}/mnt
tar xf "$image_file" -C ${WORKDIR}/mnt ||
  ufatal "Unable to write the image."
sync
umount ${user_part}

echo "

Done.

"

rm -rf ${WORKDIR}

exit 0

