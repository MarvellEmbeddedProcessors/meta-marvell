diff -urN TestFloat-2a/processors/386-GCC.h testfloat/processors/386-GCC.h
--- TestFloat-2a/processors/386-GCC.h	2002-05-27 00:07:44.000000000 +0200
+++ testfloat/processors/386-GCC.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,68 +0,0 @@
-
-/*----------------------------------------------------------------------------
-| One of the macros `BIGENDIAN' or `LITTLEENDIAN' must be defined.
-*----------------------------------------------------------------------------*/
-#define LITTLEENDIAN
-
-/*----------------------------------------------------------------------------
-| The macro `BITS64' can be defined to indicate that 64-bit integer types are
-| supported by the compiler.
-*----------------------------------------------------------------------------*/
-#define BITS64
-
-/*----------------------------------------------------------------------------
-| Each of the following `typedef's defines the most convenient type that holds
-| integers of at least as many bits as specified.  For example, `uint8' should
-| be the most convenient type that can hold unsigned integers of as many as
-| 8 bits.  The `flag' type must be able to hold either a 0 or 1.  For most
-| implementations of C, `flag', `uint8', and `int8' should all be `typedef'ed
-| to the same as `int'.
-*----------------------------------------------------------------------------*/
-typedef char flag;
-typedef unsigned char uint8;
-typedef signed char int8;
-typedef int uint16;
-typedef int int16;
-typedef unsigned int uint32;
-typedef signed int int32;
-#ifdef BITS64
-typedef unsigned long long int uint64;
-typedef signed long long int int64;
-#endif
-
-/*----------------------------------------------------------------------------
-| Each of the following `typedef's defines a type that holds integers
-| of _exactly_ the number of bits specified.  For instance, for most
-| implementation of C, `bits16' and `sbits16' should be `typedef'ed to
-| `unsigned short int' and `signed short int' (or `short int'), respectively.
-*----------------------------------------------------------------------------*/
-typedef unsigned char bits8;
-typedef signed char sbits8;
-typedef unsigned short int bits16;
-typedef signed short int sbits16;
-typedef unsigned int bits32;
-typedef signed int sbits32;
-#ifdef BITS64
-typedef unsigned long long int bits64;
-typedef signed long long int sbits64;
-#endif
-
-#ifdef BITS64
-/*----------------------------------------------------------------------------
-| The `LIT64' macro takes as its argument a textual integer literal and
-| if necessary ``marks'' the literal as having a 64-bit integer type.
-| For example, the GNU C Compiler (`gcc') requires that 64-bit literals be
-| appended with the letters `LL' standing for `long long', which is `gcc's
-| name for the 64-bit integer type.  Some compilers may allow `LIT64' to be
-| defined as the identity macro:  `#define LIT64( a ) a'.
-*----------------------------------------------------------------------------*/
-#define LIT64( a ) a##LL
-#endif
-
-/*----------------------------------------------------------------------------
-| The macro `INLINE' can be used before functions that should be inlined.  If
-| a compiler does not support explicit inlining, this macro should be defined
-| to be `static'.
-*----------------------------------------------------------------------------*/
-#define INLINE extern inline
-
diff -urN TestFloat-2a/processors/arm-gcc.h testfloat/processors/arm-gcc.h
--- TestFloat-2a/processors/arm-gcc.h	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/processors/arm-gcc.h	2008-08-17 09:46:52.000000000 +0200
@@ -0,0 +1,80 @@
+
+/*
+-------------------------------------------------------------------------------
+One of the macros `BIGENDIAN' or `LITTLEENDIAN' must be defined.
+-------------------------------------------------------------------------------
+*/
+#define LITTLEENDIAN
+
+/*
+-------------------------------------------------------------------------------
+The macro `BITS64' can be defined to indicate that 64-bit integer types are
+supported by the compiler.
+-------------------------------------------------------------------------------
+*/
+#undef BITS64
+
+/*
+-------------------------------------------------------------------------------
+Each of the following `typedef's defines the most convenient type that holds
+integers of at least as many bits as specified.  For example, `uint8' should
+be the most convenient type that can hold unsigned integers of as many as
+8 bits.  The `flag' type must be able to hold either a 0 or 1.  For most
+implementations of C, `flag', `uint8', and `int8' should all be `typedef'ed
+to the same as `int'.
+-------------------------------------------------------------------------------
+*/
+typedef char flag;
+typedef unsigned char uint8;
+typedef signed char int8;
+typedef int uint16;
+typedef int int16;
+typedef unsigned int uint32;
+typedef signed int int32;
+#ifdef BITS64
+typedef unsigned long long int uint64;
+typedef signed long long int int64;
+#endif
+
+/*
+-------------------------------------------------------------------------------
+Each of the following `typedef's defines a type that holds integers
+of _exactly_ the number of bits specified.  For instance, for most
+implementation of C, `bits16' and `sbits16' should be `typedef'ed to
+`unsigned short int' and `signed short int' (or `short int'), respectively.
+-------------------------------------------------------------------------------
+*/
+typedef unsigned char bits8;
+typedef signed char sbits8;
+typedef unsigned short int bits16;
+typedef signed short int sbits16;
+typedef unsigned int bits32;
+typedef signed int sbits32;
+#ifdef BITS64
+typedef unsigned long long int bits64;
+typedef signed long long int sbits64;
+#endif
+
+#ifdef BITS64
+/*
+-------------------------------------------------------------------------------
+The `LIT64' macro takes as its argument a textual integer literal and
+if necessary ``marks'' the literal as having a 64-bit integer type.
+For example, the GNU C Compiler (`gcc') requires that 64-bit literals be
+appended with the letters `LL' standing for `long long', which is `gcc's
+name for the 64-bit integer type.  Some compilers may allow `LIT64' to be
+defined as the identity macro:  `#define LIT64( a ) a'.
+-------------------------------------------------------------------------------
+*/
+#define LIT64( a ) a##LL
+#endif
+
+/*
+-------------------------------------------------------------------------------
+The macro `INLINE' can be used before functions that should be inlined.  If
+a compiler does not support explicit inlining, this macro should be defined
+to be `static'.
+-------------------------------------------------------------------------------
+*/
+#define INLINE extern inline
+
diff -urN TestFloat-2a/processors/SPARC-GCC.h testfloat/processors/SPARC-GCC.h
--- TestFloat-2a/processors/SPARC-GCC.h	2002-05-27 03:45:20.000000000 +0200
+++ testfloat/processors/SPARC-GCC.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,68 +0,0 @@
-
-/*----------------------------------------------------------------------------
-| One of the macros `BIGENDIAN' or `LITTLEENDIAN' must be defined.
-*----------------------------------------------------------------------------*/
-#define BIGENDIAN
-
-/*----------------------------------------------------------------------------
-| The macro `BITS64' can be defined to indicate that 64-bit integer types are
-| supported by the compiler.
-*----------------------------------------------------------------------------*/
-#define BITS64
-
-/*----------------------------------------------------------------------------
-| Each of the following `typedef's defines the most convenient type that holds
-| integers of at least as many bits as specified.  For example, `uint8' should
-| be the most convenient type that can hold unsigned integers of as many as
-| 8 bits.  The `flag' type must be able to hold either a 0 or 1.  For most
-| implementations of C, `flag', `uint8', and `int8' should all be `typedef'ed
-| to the same as `int'.
-*----------------------------------------------------------------------------*/
-typedef int flag;
-typedef int uint8;
-typedef int int8;
-typedef int uint16;
-typedef int int16;
-typedef unsigned int uint32;
-typedef signed int int32;
-#ifdef BITS64
-typedef unsigned long long int uint64;
-typedef signed long long int int64;
-#endif
-
-/*----------------------------------------------------------------------------
-| Each of the following `typedef's defines a type that holds integers
-| of _exactly_ the number of bits specified.  For instance, for most
-| implementation of C, `bits16' and `sbits16' should be `typedef'ed to
-| `unsigned short int' and `signed short int' (or `short int'), respectively.
-*----------------------------------------------------------------------------*/
-typedef unsigned char bits8;
-typedef signed char sbits8;
-typedef unsigned short int bits16;
-typedef signed short int sbits16;
-typedef unsigned int bits32;
-typedef signed int sbits32;
-#ifdef BITS64
-typedef unsigned long long int bits64;
-typedef signed long long int sbits64;
-#endif
-
-#ifdef BITS64
-/*----------------------------------------------------------------------------
-| The `LIT64' macro takes as its argument a textual integer literal and
-| if necessary ``marks'' the literal as having a 64-bit integer type.
-| For example, the GNU C Compiler (`gcc') requires that 64-bit literals be
-| appended with the letters `LL' standing for `long long', which is `gcc's
-| name for the 64-bit integer type.  Some compilers may allow `LIT64' to be
-| defined as the identity macro:  `#define LIT64( a ) a'.
-*----------------------------------------------------------------------------*/
-#define LIT64( a ) a##LL
-#endif
-
-/*----------------------------------------------------------------------------
-| The macro `INLINE' can be used before functions that should be inlined.  If
-| a compiler does not support explicit inlining, this macro should be defined
-| to be `static'.
-*----------------------------------------------------------------------------*/
-#define INLINE extern inline
-
diff -urN TestFloat-2a/softfloat/bits32/386-Win32-gcc/Makefile testfloat/softfloat/bits32/386-Win32-gcc/Makefile
--- TestFloat-2a/softfloat/bits32/386-Win32-gcc/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/softfloat/bits32/386-Win32-gcc/Makefile	2008-08-17 09:46:53.000000000 +0200
@@ -0,0 +1,24 @@
+
+PROCESSOR_H = ../../../processors/386-gcc.h
+SOFTFLOAT_MACROS = ../softfloat-macros
+
+OBJ = .o
+EXE = .exe
+INCLUDES = -I. -I..
+COMPILE_C = gcc -c -o $@ $(INCLUDES) -I- -O2
+LINK = gcc -o $@
+
+ALL: softfloat$(OBJ) timesoftfloat$(EXE)
+
+milieu.h: $(PROCESSOR_H)
+	touch milieu.h
+
+softfloat$(OBJ): milieu.h softfloat.h softfloat-specialize $(SOFTFLOAT_MACROS) ../softfloat.c
+	$(COMPILE_C) ../softfloat.c
+
+timesoftfloat$(OBJ): milieu.h softfloat.h ../timesoftfloat.c
+	$(COMPILE_C) ../timesoftfloat.c
+
+timesoftfloat$(EXE): softfloat$(OBJ) timesoftfloat$(OBJ)
+	$(LINK) softfloat$(OBJ) timesoftfloat$(OBJ)
+
diff -urN TestFloat-2a/softfloat/bits32/386-Win32-gcc/milieu.h testfloat/softfloat/bits32/386-Win32-gcc/milieu.h
--- TestFloat-2a/softfloat/bits32/386-Win32-gcc/milieu.h	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/softfloat/bits32/386-Win32-gcc/milieu.h	2008-08-17 09:46:53.000000000 +0200
@@ -0,0 +1,45 @@
+
+/*============================================================================
+
+This C header file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic
+Package, Release 2b.
+
+Written by John R. Hauser.  This work was made possible in part by the
+International Computer Science Institute, located at Suite 600, 1947 Center
+Street, Berkeley, California 94704.  Funding was partially provided by the
+National Science Foundation under grant MIP-9311980.  The original version
+of this code was written as part of a project to build a fixed-point vector
+processor in collaboration with the University of California at Berkeley,
+overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
+is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
+arithmetic/SoftFloat.html'.
+
+THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
+been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
+RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
+AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
+COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
+EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
+INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
+OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.
+
+Derivative works are acceptable, even for commercial purposes, so long as
+(1) the source code for the derivative work includes prominent notice that
+the work is derivative, and (2) the source code includes prominent notice with
+these four paragraphs for those parts of this code that are retained.
+
+=============================================================================*/
+
+/*----------------------------------------------------------------------------
+| Include common integer types and flags.
+*----------------------------------------------------------------------------*/
+#include "../../../processors/386-gcc.h"
+
+/*----------------------------------------------------------------------------
+| Symbolic Boolean literals.
+*----------------------------------------------------------------------------*/
+enum {
+    FALSE = 0,
+    TRUE  = 1
+};
+
diff -urN TestFloat-2a/softfloat/bits32/386-Win32-gcc/softfloat.h testfloat/softfloat/bits32/386-Win32-gcc/softfloat.h
--- TestFloat-2a/softfloat/bits32/386-Win32-gcc/softfloat.h	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/softfloat/bits32/386-Win32-gcc/softfloat.h	2008-08-17 09:46:53.000000000 +0200
@@ -0,0 +1,134 @@
+
+/*============================================================================
+
+This C header file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic
+Package, Release 2b.
+
+Written by John R. Hauser.  This work was made possible in part by the
+International Computer Science Institute, located at Suite 600, 1947 Center
+Street, Berkeley, California 94704.  Funding was partially provided by the
+National Science Foundation under grant MIP-9311980.  The original version
+of this code was written as part of a project to build a fixed-point vector
+processor in collaboration with the University of California at Berkeley,
+overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
+is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
+arithmetic/SoftFloat.html'.
+
+THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
+been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
+RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
+AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
+COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
+EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
+INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
+OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.
+
+Derivative works are acceptable, even for commercial purposes, so long as
+(1) the source code for the derivative work includes prominent notice that
+the work is derivative, and (2) the source code includes prominent notice with
+these four paragraphs for those parts of this code that are retained.
+
+=============================================================================*/
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE floating-point types.
+*----------------------------------------------------------------------------*/
+typedef unsigned int float32;
+typedef struct {
+    unsigned int low, high;
+} float64;
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE floating-point underflow tininess-detection mode.
+*----------------------------------------------------------------------------*/
+extern signed char float_detect_tininess;
+enum {
+    float_tininess_after_rounding  = 0,
+    float_tininess_before_rounding = 1
+};
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE floating-point rounding mode.
+*----------------------------------------------------------------------------*/
+extern signed char float_rounding_mode;
+enum {
+    float_round_nearest_even = 0,
+    float_round_down         = 1,
+    float_round_up           = 2,
+    float_round_to_zero      = 3
+};
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE floating-point exception flags.
+*----------------------------------------------------------------------------*/
+extern signed char float_exception_flags;
+enum {
+    float_flag_invalid   =  1,
+    float_flag_divbyzero =  4,
+    float_flag_overflow  =  8,
+    float_flag_underflow = 16,
+    float_flag_inexact   = 32
+};
+
+/*----------------------------------------------------------------------------
+| Routine to raise any or all of the software IEC/IEEE floating-point
+| exception flags.
+*----------------------------------------------------------------------------*/
+void float_raise( signed char );
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE integer-to-floating-point conversion routines.
+*----------------------------------------------------------------------------*/
+float32 int32_to_float32( int );
+float64 int32_to_float64( int );
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE single-precision conversion routines.
+*----------------------------------------------------------------------------*/
+int float32_to_int32( float32 );
+int float32_to_int32_round_to_zero( float32 );
+float64 float32_to_float64( float32 );
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE single-precision operations.
+*----------------------------------------------------------------------------*/
+float32 float32_round_to_int( float32 );
+float32 float32_add( float32, float32 );
+float32 float32_sub( float32, float32 );
+float32 float32_mul( float32, float32 );
+float32 float32_div( float32, float32 );
+float32 float32_rem( float32, float32 );
+float32 float32_sqrt( float32 );
+char float32_eq( float32, float32 );
+char float32_le( float32, float32 );
+char float32_lt( float32, float32 );
+char float32_eq_signaling( float32, float32 );
+char float32_le_quiet( float32, float32 );
+char float32_lt_quiet( float32, float32 );
+char float32_is_signaling_nan( float32 );
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE double-precision conversion routines.
+*----------------------------------------------------------------------------*/
+int float64_to_int32( float64 );
+int float64_to_int32_round_to_zero( float64 );
+float32 float64_to_float32( float64 );
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE double-precision operations.
+*----------------------------------------------------------------------------*/
+float64 float64_round_to_int( float64 );
+float64 float64_add( float64, float64 );
+float64 float64_sub( float64, float64 );
+float64 float64_mul( float64, float64 );
+float64 float64_div( float64, float64 );
+float64 float64_rem( float64, float64 );
+float64 float64_sqrt( float64 );
+char float64_eq( float64, float64 );
+char float64_le( float64, float64 );
+char float64_lt( float64, float64 );
+char float64_eq_signaling( float64, float64 );
+char float64_le_quiet( float64, float64 );
+char float64_lt_quiet( float64, float64 );
+char float64_is_signaling_nan( float64 );
+
diff -urN TestFloat-2a/softfloat/bits32/386-Win32-gcc/softfloat-specialize testfloat/softfloat/bits32/386-Win32-gcc/softfloat-specialize
--- TestFloat-2a/softfloat/bits32/386-Win32-gcc/softfloat-specialize	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/softfloat/bits32/386-Win32-gcc/softfloat-specialize	2008-08-17 09:46:53.000000000 +0200
@@ -0,0 +1,258 @@
+
+/*============================================================================
+
+This C source fragment is part of the SoftFloat IEC/IEEE Floating-point
+Arithmetic Package, Release 2b.
+
+Written by John R. Hauser.  This work was made possible in part by the
+International Computer Science Institute, located at Suite 600, 1947 Center
+Street, Berkeley, California 94704.  Funding was partially provided by the
+National Science Foundation under grant MIP-9311980.  The original version
+of this code was written as part of a project to build a fixed-point vector
+processor in collaboration with the University of California at Berkeley,
+overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
+is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
+arithmetic/SoftFloat.html'.
+
+THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
+been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
+RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
+AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
+COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
+EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
+INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
+OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.
+
+Derivative works are acceptable, even for commercial purposes, so long as
+(1) the source code for the derivative work includes prominent notice that
+the work is derivative, and (2) the source code includes prominent notice with
+these four paragraphs for those parts of this code that are retained.
+
+=============================================================================*/
+
+/*----------------------------------------------------------------------------
+| Underflow tininess-detection mode, statically initialized to default value.
+| (The declaration in `softfloat.h' must match the `int8' type here.)
+*----------------------------------------------------------------------------*/
+int8 float_detect_tininess = float_tininess_after_rounding;
+
+/*----------------------------------------------------------------------------
+| Raises the exceptions specified by `flags'.  Floating-point traps can be
+| defined here if desired.  It is currently not possible for such a trap
+| to substitute a result value.  If traps are not implemented, this routine
+| should be simply `float_exception_flags |= flags;'.
+*----------------------------------------------------------------------------*/
+
+void float_raise( int8 flags )
+{
+
+    float_exception_flags |= flags;
+
+}
+
+/*----------------------------------------------------------------------------
+| Internal canonical NaN format.
+*----------------------------------------------------------------------------*/
+typedef struct {
+    flag sign;
+    bits32 high, low;
+} commonNaNT;
+
+/*----------------------------------------------------------------------------
+| The pattern for a default generated single-precision NaN.
+*----------------------------------------------------------------------------*/
+enum {
+    float32_default_nan = 0xFFC00000
+};
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the single-precision floating-point value `a' is a NaN;
+| otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag float32_is_nan( float32 a )
+{
+
+    return ( 0xFF000000 < (bits32) ( a<<1 ) );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the single-precision floating-point value `a' is a signaling
+| NaN; otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag float32_is_signaling_nan( float32 a )
+{
+
+    return ( ( ( a>>22 ) & 0x1FF ) == 0x1FE ) && ( a & 0x003FFFFF );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the single-precision floating-point NaN
+| `a' to the canonical NaN format.  If `a' is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+
+static commonNaNT float32ToCommonNaN( float32 a )
+{
+    commonNaNT z;
+
+    if ( float32_is_signaling_nan( a ) ) float_raise( float_flag_invalid );
+    z.sign = a>>31;
+    z.low = 0;
+    z.high = a<<9;
+    return z;
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the canonical NaN `a' to the single-
+| precision floating-point format.
+*----------------------------------------------------------------------------*/
+
+static float32 commonNaNToFloat32( commonNaNT a )
+{
+
+    return ( ( (bits32) a.sign )<<31 ) | 0x7FC00000 | ( a.high>>9 );
+
+}
+
+/*----------------------------------------------------------------------------
+| Takes two single-precision floating-point values `a' and `b', one of which
+| is a NaN, and returns the appropriate NaN result.  If either `a' or `b' is a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+
+static float32 propagateFloat32NaN( float32 a, float32 b )
+{
+    flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;
+
+    aIsNaN = float32_is_nan( a );
+    aIsSignalingNaN = float32_is_signaling_nan( a );
+    bIsNaN = float32_is_nan( b );
+    bIsSignalingNaN = float32_is_signaling_nan( b );
+    a |= 0x00400000;
+    b |= 0x00400000;
+    if ( aIsSignalingNaN | bIsSignalingNaN ) float_raise( float_flag_invalid );
+    if ( aIsSignalingNaN ) {
+        if ( bIsSignalingNaN ) goto returnLargerSignificand;
+        return bIsNaN ? b : a;
+    }
+    else if ( aIsNaN ) {
+        if ( bIsSignalingNaN | ! bIsNaN ) return a;
+ returnLargerSignificand:
+        if ( (bits32) ( a<<1 ) < (bits32) ( b<<1 ) ) return b;
+        if ( (bits32) ( b<<1 ) < (bits32) ( a<<1 ) ) return a;
+        return ( a < b ) ? a : b;
+    }
+    else {
+        return b;
+    }
+
+}
+
+/*----------------------------------------------------------------------------
+| The pattern for a default generated double-precision NaN.  The `high' and
+| `low' values hold the most- and least-significant bits, respectively.
+*----------------------------------------------------------------------------*/
+enum {
+    float64_default_nan_high = 0xFFF80000,
+    float64_default_nan_low  = 0x00000000
+};
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the double-precision floating-point value `a' is a NaN;
+| otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag float64_is_nan( float64 a )
+{
+
+    return
+           ( 0xFFE00000 <= (bits32) ( a.high<<1 ) )
+        && ( a.low || ( a.high & 0x000FFFFF ) );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the double-precision floating-point value `a' is a signaling
+| NaN; otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag float64_is_signaling_nan( float64 a )
+{
+
+    return
+           ( ( ( a.high>>19 ) & 0xFFF ) == 0xFFE )
+        && ( a.low || ( a.high & 0x0007FFFF ) );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the double-precision floating-point NaN
+| `a' to the canonical NaN format.  If `a' is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+
+static commonNaNT float64ToCommonNaN( float64 a )
+{
+    commonNaNT z;
+
+    if ( float64_is_signaling_nan( a ) ) float_raise( float_flag_invalid );
+    z.sign = a.high>>31;
+    shortShift64Left( a.high, a.low, 12, &z.high, &z.low );
+    return z;
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the canonical NaN `a' to the double-
+| precision floating-point format.
+*----------------------------------------------------------------------------*/
+
+static float64 commonNaNToFloat64( commonNaNT a )
+{
+    float64 z;
+
+    shift64Right( a.high, a.low, 12, &z.high, &z.low );
+    z.high |= ( ( (bits32) a.sign )<<31 ) | 0x7FF80000;
+    return z;
+
+}
+
+/*----------------------------------------------------------------------------
+| Takes two double-precision floating-point values `a' and `b', one of which
+| is a NaN, and returns the appropriate NaN result.  If either `a' or `b' is a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+
+static float64 propagateFloat64NaN( float64 a, float64 b )
+{
+    flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;
+
+    aIsNaN = float64_is_nan( a );
+    aIsSignalingNaN = float64_is_signaling_nan( a );
+    bIsNaN = float64_is_nan( b );
+    bIsSignalingNaN = float64_is_signaling_nan( b );
+    a.high |= 0x00080000;
+    b.high |= 0x00080000;
+    if ( aIsSignalingNaN | bIsSignalingNaN ) float_raise( float_flag_invalid );
+    if ( aIsSignalingNaN ) {
+        if ( bIsSignalingNaN ) goto returnLargerSignificand;
+        return bIsNaN ? b : a;
+    }
+    else if ( aIsNaN ) {
+        if ( bIsSignalingNaN | ! bIsNaN ) return a;
+ returnLargerSignificand:
+        if ( lt64( a.high<<1, a.low, b.high<<1, b.low ) ) return b;
+        if ( lt64( b.high<<1, b.low, a.high<<1, a.low ) ) return a;
+        return ( a.high < b.high ) ? a : b;
+    }
+    else {
+        return b;
+    }
+
+}
+
diff -urN TestFloat-2a/softfloat/bits32/386-Win32-GCC/Makefile testfloat/softfloat/bits32/386-Win32-GCC/Makefile
--- TestFloat-2a/softfloat/bits32/386-Win32-GCC/Makefile	2002-05-27 03:11:32.000000000 +0200
+++ testfloat/softfloat/bits32/386-Win32-GCC/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,24 +0,0 @@
-
-PROCESSOR_H = ../../../processors/386-GCC.h
-SOFTFLOAT_MACROS = ../softfloat-macros
-
-OBJ = .o
-EXE = .exe
-INCLUDES = -I. -I..
-COMPILE_C = gcc -c -o $@ $(INCLUDES) -I- -O2
-LINK = gcc -o $@
-
-ALL: softfloat$(OBJ) timesoftfloat$(EXE)
-
-milieu.h: $(PROCESSOR_H)
-	touch milieu.h
-
-softfloat$(OBJ): milieu.h softfloat.h softfloat-specialize $(SOFTFLOAT_MACROS) ../softfloat.c
-	$(COMPILE_C) ../softfloat.c
-
-timesoftfloat$(OBJ): milieu.h softfloat.h ../timesoftfloat.c
-	$(COMPILE_C) ../timesoftfloat.c
-
-timesoftfloat$(EXE): softfloat$(OBJ) timesoftfloat$(OBJ)
-	$(LINK) softfloat$(OBJ) timesoftfloat$(OBJ)
-
diff -urN TestFloat-2a/softfloat/bits32/386-Win32-GCC/milieu.h testfloat/softfloat/bits32/386-Win32-GCC/milieu.h
--- TestFloat-2a/softfloat/bits32/386-Win32-GCC/milieu.h	2002-05-28 02:31:12.000000000 +0200
+++ testfloat/softfloat/bits32/386-Win32-GCC/milieu.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,45 +0,0 @@
-
-/*============================================================================
-
-This C header file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic
-Package, Release 2b.
-
-Written by John R. Hauser.  This work was made possible in part by the
-International Computer Science Institute, located at Suite 600, 1947 Center
-Street, Berkeley, California 94704.  Funding was partially provided by the
-National Science Foundation under grant MIP-9311980.  The original version
-of this code was written as part of a project to build a fixed-point vector
-processor in collaboration with the University of California at Berkeley,
-overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
-is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
-arithmetic/SoftFloat.html'.
-
-THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
-been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
-RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
-AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
-COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
-EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
-INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
-OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.
-
-Derivative works are acceptable, even for commercial purposes, so long as
-(1) the source code for the derivative work includes prominent notice that
-the work is derivative, and (2) the source code includes prominent notice with
-these four paragraphs for those parts of this code that are retained.
-
-=============================================================================*/
-
-/*----------------------------------------------------------------------------
-| Include common integer types and flags.
-*----------------------------------------------------------------------------*/
-#include "../../../processors/386-GCC.h"
-
-/*----------------------------------------------------------------------------
-| Symbolic Boolean literals.
-*----------------------------------------------------------------------------*/
-enum {
-    FALSE = 0,
-    TRUE  = 1
-};
-
diff -urN TestFloat-2a/softfloat/bits32/386-Win32-GCC/softfloat.h testfloat/softfloat/bits32/386-Win32-GCC/softfloat.h
--- TestFloat-2a/softfloat/bits32/386-Win32-GCC/softfloat.h	2002-05-27 03:28:40.000000000 +0200
+++ testfloat/softfloat/bits32/386-Win32-GCC/softfloat.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,134 +0,0 @@
-
-/*============================================================================
-
-This C header file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic
-Package, Release 2b.
-
-Written by John R. Hauser.  This work was made possible in part by the
-International Computer Science Institute, located at Suite 600, 1947 Center
-Street, Berkeley, California 94704.  Funding was partially provided by the
-National Science Foundation under grant MIP-9311980.  The original version
-of this code was written as part of a project to build a fixed-point vector
-processor in collaboration with the University of California at Berkeley,
-overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
-is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
-arithmetic/SoftFloat.html'.
-
-THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
-been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
-RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
-AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
-COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
-EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
-INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
-OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.
-
-Derivative works are acceptable, even for commercial purposes, so long as
-(1) the source code for the derivative work includes prominent notice that
-the work is derivative, and (2) the source code includes prominent notice with
-these four paragraphs for those parts of this code that are retained.
-
-=============================================================================*/
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE floating-point types.
-*----------------------------------------------------------------------------*/
-typedef unsigned int float32;
-typedef struct {
-    unsigned int low, high;
-} float64;
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE floating-point underflow tininess-detection mode.
-*----------------------------------------------------------------------------*/
-extern signed char float_detect_tininess;
-enum {
-    float_tininess_after_rounding  = 0,
-    float_tininess_before_rounding = 1
-};
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE floating-point rounding mode.
-*----------------------------------------------------------------------------*/
-extern signed char float_rounding_mode;
-enum {
-    float_round_nearest_even = 0,
-    float_round_down         = 1,
-    float_round_up           = 2,
-    float_round_to_zero      = 3
-};
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE floating-point exception flags.
-*----------------------------------------------------------------------------*/
-extern signed char float_exception_flags;
-enum {
-    float_flag_invalid   =  1,
-    float_flag_divbyzero =  4,
-    float_flag_overflow  =  8,
-    float_flag_underflow = 16,
-    float_flag_inexact   = 32
-};
-
-/*----------------------------------------------------------------------------
-| Routine to raise any or all of the software IEC/IEEE floating-point
-| exception flags.
-*----------------------------------------------------------------------------*/
-void float_raise( signed char );
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE integer-to-floating-point conversion routines.
-*----------------------------------------------------------------------------*/
-float32 int32_to_float32( int );
-float64 int32_to_float64( int );
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE single-precision conversion routines.
-*----------------------------------------------------------------------------*/
-int float32_to_int32( float32 );
-int float32_to_int32_round_to_zero( float32 );
-float64 float32_to_float64( float32 );
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE single-precision operations.
-*----------------------------------------------------------------------------*/
-float32 float32_round_to_int( float32 );
-float32 float32_add( float32, float32 );
-float32 float32_sub( float32, float32 );
-float32 float32_mul( float32, float32 );
-float32 float32_div( float32, float32 );
-float32 float32_rem( float32, float32 );
-float32 float32_sqrt( float32 );
-char float32_eq( float32, float32 );
-char float32_le( float32, float32 );
-char float32_lt( float32, float32 );
-char float32_eq_signaling( float32, float32 );
-char float32_le_quiet( float32, float32 );
-char float32_lt_quiet( float32, float32 );
-char float32_is_signaling_nan( float32 );
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE double-precision conversion routines.
-*----------------------------------------------------------------------------*/
-int float64_to_int32( float64 );
-int float64_to_int32_round_to_zero( float64 );
-float32 float64_to_float32( float64 );
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE double-precision operations.
-*----------------------------------------------------------------------------*/
-float64 float64_round_to_int( float64 );
-float64 float64_add( float64, float64 );
-float64 float64_sub( float64, float64 );
-float64 float64_mul( float64, float64 );
-float64 float64_div( float64, float64 );
-float64 float64_rem( float64, float64 );
-float64 float64_sqrt( float64 );
-char float64_eq( float64, float64 );
-char float64_le( float64, float64 );
-char float64_lt( float64, float64 );
-char float64_eq_signaling( float64, float64 );
-char float64_le_quiet( float64, float64 );
-char float64_lt_quiet( float64, float64 );
-char float64_is_signaling_nan( float64 );
-
diff -urN TestFloat-2a/softfloat/bits32/386-Win32-GCC/softfloat-specialize testfloat/softfloat/bits32/386-Win32-GCC/softfloat-specialize
--- TestFloat-2a/softfloat/bits32/386-Win32-GCC/softfloat-specialize	2002-05-27 03:32:14.000000000 +0200
+++ testfloat/softfloat/bits32/386-Win32-GCC/softfloat-specialize	1970-01-01 01:00:00.000000000 +0100
@@ -1,258 +0,0 @@
-
-/*============================================================================
-
-This C source fragment is part of the SoftFloat IEC/IEEE Floating-point
-Arithmetic Package, Release 2b.
-
-Written by John R. Hauser.  This work was made possible in part by the
-International Computer Science Institute, located at Suite 600, 1947 Center
-Street, Berkeley, California 94704.  Funding was partially provided by the
-National Science Foundation under grant MIP-9311980.  The original version
-of this code was written as part of a project to build a fixed-point vector
-processor in collaboration with the University of California at Berkeley,
-overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
-is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
-arithmetic/SoftFloat.html'.
-
-THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
-been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
-RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
-AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
-COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
-EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
-INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
-OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.
-
-Derivative works are acceptable, even for commercial purposes, so long as
-(1) the source code for the derivative work includes prominent notice that
-the work is derivative, and (2) the source code includes prominent notice with
-these four paragraphs for those parts of this code that are retained.
-
-=============================================================================*/
-
-/*----------------------------------------------------------------------------
-| Underflow tininess-detection mode, statically initialized to default value.
-| (The declaration in `softfloat.h' must match the `int8' type here.)
-*----------------------------------------------------------------------------*/
-int8 float_detect_tininess = float_tininess_after_rounding;
-
-/*----------------------------------------------------------------------------
-| Raises the exceptions specified by `flags'.  Floating-point traps can be
-| defined here if desired.  It is currently not possible for such a trap
-| to substitute a result value.  If traps are not implemented, this routine
-| should be simply `float_exception_flags |= flags;'.
-*----------------------------------------------------------------------------*/
-
-void float_raise( int8 flags )
-{
-
-    float_exception_flags |= flags;
-
-}
-
-/*----------------------------------------------------------------------------
-| Internal canonical NaN format.
-*----------------------------------------------------------------------------*/
-typedef struct {
-    flag sign;
-    bits32 high, low;
-} commonNaNT;
-
-/*----------------------------------------------------------------------------
-| The pattern for a default generated single-precision NaN.
-*----------------------------------------------------------------------------*/
-enum {
-    float32_default_nan = 0xFFC00000
-};
-
-/*----------------------------------------------------------------------------
-| Returns 1 if the single-precision floating-point value `a' is a NaN;
-| otherwise returns 0.
-*----------------------------------------------------------------------------*/
-
-flag float32_is_nan( float32 a )
-{
-
-    return ( 0xFF000000 < (bits32) ( a<<1 ) );
-
-}
-
-/*----------------------------------------------------------------------------
-| Returns 1 if the single-precision floating-point value `a' is a signaling
-| NaN; otherwise returns 0.
-*----------------------------------------------------------------------------*/
-
-flag float32_is_signaling_nan( float32 a )
-{
-
-    return ( ( ( a>>22 ) & 0x1FF ) == 0x1FE ) && ( a & 0x003FFFFF );
-
-}
-
-/*----------------------------------------------------------------------------
-| Returns the result of converting the single-precision floating-point NaN
-| `a' to the canonical NaN format.  If `a' is a signaling NaN, the invalid
-| exception is raised.
-*----------------------------------------------------------------------------*/
-
-static commonNaNT float32ToCommonNaN( float32 a )
-{
-    commonNaNT z;
-
-    if ( float32_is_signaling_nan( a ) ) float_raise( float_flag_invalid );
-    z.sign = a>>31;
-    z.low = 0;
-    z.high = a<<9;
-    return z;
-
-}
-
-/*----------------------------------------------------------------------------
-| Returns the result of converting the canonical NaN `a' to the single-
-| precision floating-point format.
-*----------------------------------------------------------------------------*/
-
-static float32 commonNaNToFloat32( commonNaNT a )
-{
-
-    return ( ( (bits32) a.sign )<<31 ) | 0x7FC00000 | ( a.high>>9 );
-
-}
-
-/*----------------------------------------------------------------------------
-| Takes two single-precision floating-point values `a' and `b', one of which
-| is a NaN, and returns the appropriate NaN result.  If either `a' or `b' is a
-| signaling NaN, the invalid exception is raised.
-*----------------------------------------------------------------------------*/
-
-static float32 propagateFloat32NaN( float32 a, float32 b )
-{
-    flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;
-
-    aIsNaN = float32_is_nan( a );
-    aIsSignalingNaN = float32_is_signaling_nan( a );
-    bIsNaN = float32_is_nan( b );
-    bIsSignalingNaN = float32_is_signaling_nan( b );
-    a |= 0x00400000;
-    b |= 0x00400000;
-    if ( aIsSignalingNaN | bIsSignalingNaN ) float_raise( float_flag_invalid );
-    if ( aIsSignalingNaN ) {
-        if ( bIsSignalingNaN ) goto returnLargerSignificand;
-        return bIsNaN ? b : a;
-    }
-    else if ( aIsNaN ) {
-        if ( bIsSignalingNaN | ! bIsNaN ) return a;
- returnLargerSignificand:
-        if ( (bits32) ( a<<1 ) < (bits32) ( b<<1 ) ) return b;
-        if ( (bits32) ( b<<1 ) < (bits32) ( a<<1 ) ) return a;
-        return ( a < b ) ? a : b;
-    }
-    else {
-        return b;
-    }
-
-}
-
-/*----------------------------------------------------------------------------
-| The pattern for a default generated double-precision NaN.  The `high' and
-| `low' values hold the most- and least-significant bits, respectively.
-*----------------------------------------------------------------------------*/
-enum {
-    float64_default_nan_high = 0xFFF80000,
-    float64_default_nan_low  = 0x00000000
-};
-
-/*----------------------------------------------------------------------------
-| Returns 1 if the double-precision floating-point value `a' is a NaN;
-| otherwise returns 0.
-*----------------------------------------------------------------------------*/
-
-flag float64_is_nan( float64 a )
-{
-
-    return
-           ( 0xFFE00000 <= (bits32) ( a.high<<1 ) )
-        && ( a.low || ( a.high & 0x000FFFFF ) );
-
-}
-
-/*----------------------------------------------------------------------------
-| Returns 1 if the double-precision floating-point value `a' is a signaling
-| NaN; otherwise returns 0.
-*----------------------------------------------------------------------------*/
-
-flag float64_is_signaling_nan( float64 a )
-{
-
-    return
-           ( ( ( a.high>>19 ) & 0xFFF ) == 0xFFE )
-        && ( a.low || ( a.high & 0x0007FFFF ) );
-
-}
-
-/*----------------------------------------------------------------------------
-| Returns the result of converting the double-precision floating-point NaN
-| `a' to the canonical NaN format.  If `a' is a signaling NaN, the invalid
-| exception is raised.
-*----------------------------------------------------------------------------*/
-
-static commonNaNT float64ToCommonNaN( float64 a )
-{
-    commonNaNT z;
-
-    if ( float64_is_signaling_nan( a ) ) float_raise( float_flag_invalid );
-    z.sign = a.high>>31;
-    shortShift64Left( a.high, a.low, 12, &z.high, &z.low );
-    return z;
-
-}
-
-/*----------------------------------------------------------------------------
-| Returns the result of converting the canonical NaN `a' to the double-
-| precision floating-point format.
-*----------------------------------------------------------------------------*/
-
-static float64 commonNaNToFloat64( commonNaNT a )
-{
-    float64 z;
-
-    shift64Right( a.high, a.low, 12, &z.high, &z.low );
-    z.high |= ( ( (bits32) a.sign )<<31 ) | 0x7FF80000;
-    return z;
-
-}
-
-/*----------------------------------------------------------------------------
-| Takes two double-precision floating-point values `a' and `b', one of which
-| is a NaN, and returns the appropriate NaN result.  If either `a' or `b' is a
-| signaling NaN, the invalid exception is raised.
-*----------------------------------------------------------------------------*/
-
-static float64 propagateFloat64NaN( float64 a, float64 b )
-{
-    flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;
-
-    aIsNaN = float64_is_nan( a );
-    aIsSignalingNaN = float64_is_signaling_nan( a );
-    bIsNaN = float64_is_nan( b );
-    bIsSignalingNaN = float64_is_signaling_nan( b );
-    a.high |= 0x00080000;
-    b.high |= 0x00080000;
-    if ( aIsSignalingNaN | bIsSignalingNaN ) float_raise( float_flag_invalid );
-    if ( aIsSignalingNaN ) {
-        if ( bIsSignalingNaN ) goto returnLargerSignificand;
-        return bIsNaN ? b : a;
-    }
-    else if ( aIsNaN ) {
-        if ( bIsSignalingNaN | ! bIsNaN ) return a;
- returnLargerSignificand:
-        if ( lt64( a.high<<1, a.low, b.high<<1, b.low ) ) return b;
-        if ( lt64( b.high<<1, b.low, a.high<<1, a.low ) ) return a;
-        return ( a.high < b.high ) ? a : b;
-    }
-    else {
-        return b;
-    }
-
-}
-
diff -urN TestFloat-2a/softfloat/bits32/arm-linux-gcc/Makefile testfloat/softfloat/bits32/arm-linux-gcc/Makefile
--- TestFloat-2a/softfloat/bits32/arm-linux-gcc/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/softfloat/bits32/arm-linux-gcc/Makefile	2013-12-02 18:51:56.037968205 +0100
@@ -0,0 +1,27 @@
+
+PROCESSOR_H = ../../../processors/arm-gcc.h
+SOFTFLOAT_MACROS = ../softfloat-macros
+
+OBJ = .o
+EXE = .exe
+INCLUDES = -I. -I..
+COMPILE_C = $(CROSS_COMPILE)gcc -c -o $@ $(INCLUDES) -I- -O2
+LINK = $(CROSS_COMPILE)gcc -o $@
+
+all: softfloat$(OBJ) timesoftfloat$(EXE)
+
+milieu.h: $(PROCESSOR_H)
+	touch milieu.h
+
+softfloat$(OBJ): milieu.h softfloat.h softfloat-specialize $(SOFTFLOAT_MACROS) ../softfloat.c
+	$(COMPILE_C) ../softfloat.c
+
+timesoftfloat$(OBJ): milieu.h softfloat.h ../timesoftfloat.c
+	$(COMPILE_C) ../timesoftfloat.c
+
+timesoftfloat$(EXE): softfloat$(OBJ) timesoftfloat$(OBJ)
+	$(LINK) softfloat$(OBJ) timesoftfloat$(OBJ)
+
+clean: 
+	rm *.o
+	rm *.exe
diff -urN TestFloat-2a/softfloat/bits32/arm-linux-gcc/milieu.h testfloat/softfloat/bits32/arm-linux-gcc/milieu.h
--- TestFloat-2a/softfloat/bits32/arm-linux-gcc/milieu.h	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/softfloat/bits32/arm-linux-gcc/milieu.h	2008-08-17 09:46:53.000000000 +0200
@@ -0,0 +1,45 @@
+
+/*============================================================================
+
+This C header file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic
+Package, Release 2b.
+
+Written by John R. Hauser.  This work was made possible in part by the
+International Computer Science Institute, located at Suite 600, 1947 Center
+Street, Berkeley, California 94704.  Funding was partially provided by the
+National Science Foundation under grant MIP-9311980.  The original version
+of this code was written as part of a project to build a fixed-point vector
+processor in collaboration with the University of California at Berkeley,
+overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
+is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
+arithmetic/SoftFloat.html'.
+
+THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
+been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
+RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
+AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
+COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
+EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
+INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
+OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.
+
+Derivative works are acceptable, even for commercial purposes, so long as
+(1) the source code for the derivative work includes prominent notice that
+the work is derivative, and (2) the source code includes prominent notice with
+these four paragraphs for those parts of this code that are retained.
+
+=============================================================================*/
+
+/*----------------------------------------------------------------------------
+| Include common integer types and flags.
+*----------------------------------------------------------------------------*/
+#include "../../../processors/arm-gcc.h"
+
+/*----------------------------------------------------------------------------
+| Symbolic Boolean literals.
+*----------------------------------------------------------------------------*/
+enum {
+    FALSE = 0,
+    TRUE  = 1
+};
+
diff -urN TestFloat-2a/softfloat/bits32/arm-linux-gcc/softfloat.h testfloat/softfloat/bits32/arm-linux-gcc/softfloat.h
--- TestFloat-2a/softfloat/bits32/arm-linux-gcc/softfloat.h	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/softfloat/bits32/arm-linux-gcc/softfloat.h	2008-08-17 09:46:53.000000000 +0200
@@ -0,0 +1,134 @@
+
+/*============================================================================
+
+This C header file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic
+Package, Release 2b.
+
+Written by John R. Hauser.  This work was made possible in part by the
+International Computer Science Institute, located at Suite 600, 1947 Center
+Street, Berkeley, California 94704.  Funding was partially provided by the
+National Science Foundation under grant MIP-9311980.  The original version
+of this code was written as part of a project to build a fixed-point vector
+processor in collaboration with the University of California at Berkeley,
+overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
+is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
+arithmetic/SoftFloat.html'.
+
+THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
+been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
+RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
+AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
+COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
+EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
+INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
+OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.
+
+Derivative works are acceptable, even for commercial purposes, so long as
+(1) the source code for the derivative work includes prominent notice that
+the work is derivative, and (2) the source code includes prominent notice with
+these four paragraphs for those parts of this code that are retained.
+
+=============================================================================*/
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE floating-point types.
+*----------------------------------------------------------------------------*/
+typedef unsigned int float32;
+typedef struct {
+    unsigned int low, high;
+} float64;
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE floating-point underflow tininess-detection mode.
+*----------------------------------------------------------------------------*/
+extern signed char float_detect_tininess;
+enum {
+    float_tininess_after_rounding  = 0,
+    float_tininess_before_rounding = 1
+};
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE floating-point rounding mode.
+*----------------------------------------------------------------------------*/
+extern signed char float_rounding_mode;
+enum {
+    float_round_nearest_even = 0,
+    float_round_up           = 1,
+    float_round_down         = 2,    
+    float_round_to_zero      = 3
+};
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE floating-point exception flags.
+*----------------------------------------------------------------------------*/
+extern signed char float_exception_flags;
+enum {
+    float_flag_invalid   =  1,
+    float_flag_divbyzero =  2,
+    float_flag_overflow  =  4,
+    float_flag_underflow = 8,
+    float_flag_inexact   = 16
+};
+
+/*----------------------------------------------------------------------------
+| Routine to raise any or all of the software IEC/IEEE floating-point
+| exception flags.
+*----------------------------------------------------------------------------*/
+void float_raise( signed char );
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE integer-to-floating-point conversion routines.
+*----------------------------------------------------------------------------*/
+float32 int32_to_float32( int );
+float64 int32_to_float64( int );
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE single-precision conversion routines.
+*----------------------------------------------------------------------------*/
+int float32_to_int32( float32 );
+int float32_to_int32_round_to_zero( float32 );
+float64 float32_to_float64( float32 );
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE single-precision operations.
+*----------------------------------------------------------------------------*/
+float32 float32_round_to_int( float32 );
+float32 float32_add( float32, float32 );
+float32 float32_sub( float32, float32 );
+float32 float32_mul( float32, float32 );
+float32 float32_div( float32, float32 );
+float32 float32_rem( float32, float32 );
+float32 float32_sqrt( float32 );
+char float32_eq( float32, float32 );
+char float32_le( float32, float32 );
+char float32_lt( float32, float32 );
+char float32_eq_signaling( float32, float32 );
+char float32_le_quiet( float32, float32 );
+char float32_lt_quiet( float32, float32 );
+char float32_is_signaling_nan( float32 );
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE double-precision conversion routines.
+*----------------------------------------------------------------------------*/
+int float64_to_int32( float64 );
+int float64_to_int32_round_to_zero( float64 );
+float32 float64_to_float32( float64 );
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE double-precision operations.
+*----------------------------------------------------------------------------*/
+float64 float64_round_to_int( float64 );
+float64 float64_add( float64, float64 );
+float64 float64_sub( float64, float64 );
+float64 float64_mul( float64, float64 );
+float64 float64_div( float64, float64 );
+float64 float64_rem( float64, float64 );
+float64 float64_sqrt( float64 );
+char float64_eq( float64, float64 );
+char float64_le( float64, float64 );
+char float64_lt( float64, float64 );
+char float64_eq_signaling( float64, float64 );
+char float64_le_quiet( float64, float64 );
+char float64_lt_quiet( float64, float64 );
+char float64_is_signaling_nan( float64 );
+
diff -urN TestFloat-2a/softfloat/bits32/arm-linux-gcc/softfloat-specialize testfloat/softfloat/bits32/arm-linux-gcc/softfloat-specialize
--- TestFloat-2a/softfloat/bits32/arm-linux-gcc/softfloat-specialize	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/softfloat/bits32/arm-linux-gcc/softfloat-specialize	2008-08-17 09:46:53.000000000 +0200
@@ -0,0 +1,258 @@
+
+/*============================================================================
+
+This C source fragment is part of the SoftFloat IEC/IEEE Floating-point
+Arithmetic Package, Release 2b.
+
+Written by John R. Hauser.  This work was made possible in part by the
+International Computer Science Institute, located at Suite 600, 1947 Center
+Street, Berkeley, California 94704.  Funding was partially provided by the
+National Science Foundation under grant MIP-9311980.  The original version
+of this code was written as part of a project to build a fixed-point vector
+processor in collaboration with the University of California at Berkeley,
+overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
+is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
+arithmetic/SoftFloat.html'.
+
+THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
+been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
+RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
+AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
+COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
+EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
+INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
+OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.
+
+Derivative works are acceptable, even for commercial purposes, so long as
+(1) the source code for the derivative work includes prominent notice that
+the work is derivative, and (2) the source code includes prominent notice with
+these four paragraphs for those parts of this code that are retained.
+
+=============================================================================*/
+
+/*----------------------------------------------------------------------------
+| Underflow tininess-detection mode, statically initialized to default value.
+| (The declaration in `softfloat.h' must match the `int8' type here.)
+*----------------------------------------------------------------------------*/
+int8 float_detect_tininess = float_tininess_before_rounding; /*float_tininess_after_rounding*/
+
+/*----------------------------------------------------------------------------
+| Raises the exceptions specified by `flags'.  Floating-point traps can be
+| defined here if desired.  It is currently not possible for such a trap
+| to substitute a result value.  If traps are not implemented, this routine
+| should be simply `float_exception_flags |= flags;'.
+*----------------------------------------------------------------------------*/
+
+void float_raise( int8 flags )
+{
+
+    float_exception_flags |= flags;
+
+}
+
+/*----------------------------------------------------------------------------
+| Internal canonical NaN format.
+*----------------------------------------------------------------------------*/
+typedef struct {
+    flag sign;
+    bits32 high, low;
+} commonNaNT;
+
+/*----------------------------------------------------------------------------
+| The pattern for a default generated single-precision NaN.
+*----------------------------------------------------------------------------*/
+enum {
+    float32_default_nan = 0xFFC00000
+};
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the single-precision floating-point value `a' is a NaN;
+| otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag float32_is_nan( float32 a )
+{
+
+    return ( 0xFF000000 < (bits32) ( a<<1 ) );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the single-precision floating-point value `a' is a signaling
+| NaN; otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag float32_is_signaling_nan( float32 a )
+{
+
+    return ( ( ( a>>22 ) & 0x1FF ) == 0x1FE ) && ( a & 0x003FFFFF );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the single-precision floating-point NaN
+| `a' to the canonical NaN format.  If `a' is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+
+static commonNaNT float32ToCommonNaN( float32 a )
+{
+    commonNaNT z;
+
+    if ( float32_is_signaling_nan( a ) ) float_raise( float_flag_invalid );
+    z.sign = a>>31;
+    z.low = 0;
+    z.high = a<<9;
+    return z;
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the canonical NaN `a' to the single-
+| precision floating-point format.
+*----------------------------------------------------------------------------*/
+
+static float32 commonNaNToFloat32( commonNaNT a )
+{
+
+    return ( ( (bits32) a.sign )<<31 ) | 0x7FC00000 | ( a.high>>9 );
+
+}
+
+/*----------------------------------------------------------------------------
+| Takes two single-precision floating-point values `a' and `b', one of which
+| is a NaN, and returns the appropriate NaN result.  If either `a' or `b' is a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+
+static float32 propagateFloat32NaN( float32 a, float32 b )
+{
+    flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;
+
+    aIsNaN = float32_is_nan( a );
+    aIsSignalingNaN = float32_is_signaling_nan( a );
+    bIsNaN = float32_is_nan( b );
+    bIsSignalingNaN = float32_is_signaling_nan( b );
+    a |= 0x00400000;
+    b |= 0x00400000;
+    if ( aIsSignalingNaN | bIsSignalingNaN ) float_raise( float_flag_invalid );
+    if ( aIsSignalingNaN ) {
+        if ( bIsSignalingNaN ) goto returnLargerSignificand;
+        return bIsNaN ? b : a;
+    }
+    else if ( aIsNaN ) {
+        if ( bIsSignalingNaN | ! bIsNaN ) return a;
+ returnLargerSignificand:
+        if ( (bits32) ( a<<1 ) < (bits32) ( b<<1 ) ) return b;
+        if ( (bits32) ( b<<1 ) < (bits32) ( a<<1 ) ) return a;
+        return ( a < b ) ? a : b;
+    }
+    else {
+        return b;
+    }
+
+}
+
+/*----------------------------------------------------------------------------
+| The pattern for a default generated double-precision NaN.  The `high' and
+| `low' values hold the most- and least-significant bits, respectively.
+*----------------------------------------------------------------------------*/
+enum {
+    float64_default_nan_high = 0xFFF80000,
+    float64_default_nan_low  = 0x00000000
+};
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the double-precision floating-point value `a' is a NaN;
+| otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag float64_is_nan( float64 a )
+{
+
+    return
+           ( 0xFFE00000 <= (bits32) ( a.high<<1 ) )
+        && ( a.low || ( a.high & 0x000FFFFF ) );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the double-precision floating-point value `a' is a signaling
+| NaN; otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag float64_is_signaling_nan( float64 a )
+{
+
+    return
+           ( ( ( a.high>>19 ) & 0xFFF ) == 0xFFE )
+        && ( a.low || ( a.high & 0x0007FFFF ) );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the double-precision floating-point NaN
+| `a' to the canonical NaN format.  If `a' is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+
+static commonNaNT float64ToCommonNaN( float64 a )
+{
+    commonNaNT z;
+
+    if ( float64_is_signaling_nan( a ) ) float_raise( float_flag_invalid );
+    z.sign = a.high>>31;
+    shortShift64Left( a.high, a.low, 12, &z.high, &z.low );
+    return z;
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the canonical NaN `a' to the double-
+| precision floating-point format.
+*----------------------------------------------------------------------------*/
+
+static float64 commonNaNToFloat64( commonNaNT a )
+{
+    float64 z;
+
+    shift64Right( a.high, a.low, 12, &z.high, &z.low );
+    z.high |= ( ( (bits32) a.sign )<<31 ) | 0x7FF80000;
+    return z;
+
+}
+
+/*----------------------------------------------------------------------------
+| Takes two double-precision floating-point values `a' and `b', one of which
+| is a NaN, and returns the appropriate NaN result.  If either `a' or `b' is a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+
+static float64 propagateFloat64NaN( float64 a, float64 b )
+{
+    flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;
+
+    aIsNaN = float64_is_nan( a );
+    aIsSignalingNaN = float64_is_signaling_nan( a );
+    bIsNaN = float64_is_nan( b );
+    bIsSignalingNaN = float64_is_signaling_nan( b );
+    a.high |= 0x00080000;
+    b.high |= 0x00080000;
+    if ( aIsSignalingNaN | bIsSignalingNaN ) float_raise( float_flag_invalid );
+    if ( aIsSignalingNaN ) {
+        if ( bIsSignalingNaN ) goto returnLargerSignificand;
+        return bIsNaN ? b : a;
+    }
+    else if ( aIsNaN ) {
+        if ( bIsSignalingNaN | ! bIsNaN ) return a;
+ returnLargerSignificand:
+        if ( lt64( a.high<<1, a.low, b.high<<1, b.low ) ) return b;
+        if ( lt64( b.high<<1, b.low, a.high<<1, a.low ) ) return a;
+        return ( a.high < b.high ) ? a : b;
+    }
+    else {
+        return b;
+    }
+
+}
+
diff -urN TestFloat-2a/softfloat/bits32/softfloat.c testfloat/softfloat/bits32/softfloat.c
--- TestFloat-2a/softfloat/bits32/softfloat.c	2002-05-27 03:25:40.000000000 +0200
+++ testfloat/softfloat/bits32/softfloat.c	2008-08-17 09:46:53.000000000 +0200
@@ -530,10 +530,18 @@
         if ( 0x9E <= aExp ) {
             if ( a != 0xCF000000 ) {
                 float_raise( float_flag_invalid );
+#if 0 /* assaf, not ARM compatible code */
                 if ( ! aSign || ( ( aExp == 0xFF ) && aSig ) ) {
-                    return 0x7FFFFFFF;
+			return 0x7FFFFFFF;
                 }
-            }
+#endif
+                if (( aExp == 0xFF ) && aSig ) {
+			return 0; /* This is NaN. ARM architecture returns 0 */
+		}
+                else if ( ! aSign ) {
+        		return 0x7FFFFFFF;
+                }
+    	    }
             return (sbits32) 0x80000000;
         }
         z = ( aSig | 0x00800000 )<<shiftCount;
@@ -597,8 +605,18 @@
     if ( 0 <= shiftCount ) {
         if ( a != 0xCF000000 ) {
             float_raise( float_flag_invalid );
-            if ( ! aSign || ( ( aExp == 0xFF ) && aSig ) ) return 0x7FFFFFFF;
-        }
+#if 0 /* assaf, not ARM compatible code */
+            if ( ! aSign || ( ( aExp == 0xFF ) && aSig ) ) {
+			return 0x7FFFFFFF;
+            }
+#endif
+            if (( aExp == 0xFF ) && aSig ) {
+		return 0; /* This is NaN. ARM architecture returns 0 */
+	    }
+            else if ( ! aSign ) {
+        	return 0x7FFFFFFF;
+            }
+    	}
         return (sbits32) 0x80000000;
     }
     else if ( aExp <= 0x7E ) {
@@ -1325,8 +1343,18 @@
     shiftCount = aExp - 0x413;
     if ( 0 <= shiftCount ) {
         if ( 0x41E < aExp ) {
-            if ( ( aExp == 0x7FF ) && ( aSig0 | aSig1 ) ) aSign = 0;
-            goto invalid;
+             if ( ( aExp == 0x7FF ) && ( aSig0 | aSig1 ) ) {
+        	float_raise( float_flag_invalid );
+	        return 0; /* In case NaN, ARM architecture returns 0 */
+             } 
+	     else {
+		aSign = 0;
+	        goto invalid;
+	     }
+#if 0 /* Assaf, this code is wrong for ARM rchitecture */ 
+           if ( ( aExp == 0x7FF ) && ( aSig0 | aSig1 ) ) aSign = 0;
+            	goto invalid;
+#endif
         }
         shortShift64Left(
             aSig0 | 0x00100000, aSig1, shiftCount, &absZ, &aSigExtra );
@@ -1396,10 +1424,20 @@
     shiftCount = aExp - 0x413;
     if ( 0 <= shiftCount ) {
         if ( 0x41E < aExp ) {
-            if ( ( aExp == 0x7FF ) && ( aSig0 | aSig1 ) ) aSign = 0;
-            goto invalid;
+             if ( ( aExp == 0x7FF ) && ( aSig0 | aSig1 ) ) {
+        	float_raise( float_flag_invalid );
+	        return 0; /* In case NaN, ARM architecture returns 0 */
+             } 
+	     else {
+		aSign = 0;
+	        goto invalid;
+	     }
+#if 0 /* Assaf, this code is wrong for ARM rchitecture */ 
+           if ( ( aExp == 0x7FF ) && ( aSig0 | aSig1 ) ) aSign = 0;
+            	goto invalid;
+#endif
         }
-        shortShift64Left(
+       shortShift64Left(
             aSig0 | 0x00100000, aSig1, shiftCount, &absZ, &aSigExtra );
     }
     else {
Binarne pliki TestFloat-2a/softfloat/bits32/.softfloat.c.swm i testfloat/softfloat/bits32/.softfloat.c.swm różnią się
Binarne pliki TestFloat-2a/softfloat/bits32/.softfloat.c.swn i testfloat/softfloat/bits32/.softfloat.c.swn różnią się
Binarne pliki TestFloat-2a/softfloat/bits32/.softfloat.c.swo i testfloat/softfloat/bits32/.softfloat.c.swo różnią się
diff -urN TestFloat-2a/softfloat/bits64/386-Win32-gcc/Makefile testfloat/softfloat/bits64/386-Win32-gcc/Makefile
--- TestFloat-2a/softfloat/bits64/386-Win32-gcc/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/softfloat/bits64/386-Win32-gcc/Makefile	2008-08-17 09:46:53.000000000 +0200
@@ -0,0 +1,24 @@
+
+PROCESSOR_H = ../../../processors/386-gcc.h
+SOFTFLOAT_MACROS = ../softfloat-macros
+
+OBJ = .o
+EXE = .exe
+INCLUDES = -I. -I..
+COMPILE_C = gcc -c -o $@ $(INCLUDES) -I- -O2
+LINK = gcc -o $@
+
+ALL: softfloat$(OBJ) timesoftfloat$(EXE)
+
+milieu.h: $(PROCESSOR_H)
+	touch milieu.h
+
+softfloat$(OBJ): milieu.h softfloat.h softfloat-specialize $(SOFTFLOAT_MACROS) ../softfloat.c
+	$(COMPILE_C) ../softfloat.c
+
+timesoftfloat$(OBJ): milieu.h softfloat.h ../timesoftfloat.c
+	$(COMPILE_C) ../timesoftfloat.c
+
+timesoftfloat$(EXE): softfloat$(OBJ) timesoftfloat$(OBJ)
+	$(LINK) softfloat$(OBJ) timesoftfloat$(OBJ)
+
diff -urN TestFloat-2a/softfloat/bits64/386-Win32-gcc/milieu.h testfloat/softfloat/bits64/386-Win32-gcc/milieu.h
--- TestFloat-2a/softfloat/bits64/386-Win32-gcc/milieu.h	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/softfloat/bits64/386-Win32-gcc/milieu.h	2008-08-17 09:46:53.000000000 +0200
@@ -0,0 +1,45 @@
+
+/*============================================================================
+
+This C header file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic
+Package, Release 2b.
+
+Written by John R. Hauser.  This work was made possible in part by the
+International Computer Science Institute, located at Suite 600, 1947 Center
+Street, Berkeley, California 94704.  Funding was partially provided by the
+National Science Foundation under grant MIP-9311980.  The original version
+of this code was written as part of a project to build a fixed-point vector
+processor in collaboration with the University of California at Berkeley,
+overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
+is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
+arithmetic/SoftFloat.html'.
+
+THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
+been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
+RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
+AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
+COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
+EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
+INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
+OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.
+
+Derivative works are acceptable, even for commercial purposes, so long as
+(1) the source code for the derivative work includes prominent notice that
+the work is derivative, and (2) the source code includes prominent notice with
+these four paragraphs for those parts of this code that are retained.
+
+=============================================================================*/
+
+/*----------------------------------------------------------------------------
+| Include common integer types and flags.
+*----------------------------------------------------------------------------*/
+#include "../../../processors/386-gcc.h"
+
+/*----------------------------------------------------------------------------
+| Symbolic Boolean literals.
+*----------------------------------------------------------------------------*/
+enum {
+    FALSE = 0,
+    TRUE  = 1
+};
+
diff -urN TestFloat-2a/softfloat/bits64/386-Win32-gcc/softfloat.h testfloat/softfloat/bits64/386-Win32-gcc/softfloat.h
--- TestFloat-2a/softfloat/bits64/386-Win32-gcc/softfloat.h	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/softfloat/bits64/386-Win32-gcc/softfloat.h	2008-08-17 09:46:53.000000000 +0200
@@ -0,0 +1,260 @@
+
+/*============================================================================
+
+This C header file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic
+Package, Release 2b.
+
+Written by John R. Hauser.  This work was made possible in part by the
+International Computer Science Institute, located at Suite 600, 1947 Center
+Street, Berkeley, California 94704.  Funding was partially provided by the
+National Science Foundation under grant MIP-9311980.  The original version
+of this code was written as part of a project to build a fixed-point vector
+processor in collaboration with the University of California at Berkeley,
+overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
+is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
+arithmetic/SoftFloat.html'.
+
+THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
+been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
+RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
+AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
+COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
+EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
+INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
+OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.
+
+Derivative works are acceptable, even for commercial purposes, so long as
+(1) the source code for the derivative work includes prominent notice that
+the work is derivative, and (2) the source code includes prominent notice with
+these four paragraphs for those parts of this code that are retained.
+
+=============================================================================*/
+
+/*----------------------------------------------------------------------------
+| The macro `FLOATX80' must be defined to enable the extended double-precision
+| floating-point format `floatx80'.  If this macro is not defined, the
+| `floatx80' type will not be defined, and none of the functions that either
+| input or output the `floatx80' type will be defined.  The same applies to
+| the `FLOAT128' macro and the quadruple-precision format `float128'.
+*----------------------------------------------------------------------------*/
+
+#define FLOATX80
+#define FLOAT128
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE floating-point types.
+*----------------------------------------------------------------------------*/
+typedef unsigned int float32;
+typedef unsigned long long float64;
+#ifdef FLOATX80
+typedef struct {
+    unsigned long long low;
+    unsigned short high;
+} floatx80;
+#endif
+#ifdef FLOAT128
+typedef struct {
+    unsigned long long low, high;
+} float128;
+#endif
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE floating-point underflow tininess-detection mode.
+*----------------------------------------------------------------------------*/
+extern signed char float_detect_tininess;
+enum {
+    float_tininess_after_rounding  = 0,
+    float_tininess_before_rounding = 1
+};
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE floating-point rounding mode.
+*----------------------------------------------------------------------------*/
+extern signed char float_rounding_mode;
+enum {
+    float_round_nearest_even = 0,
+    float_round_down         = 1,
+    float_round_up           = 2,
+    float_round_to_zero      = 3
+};
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE floating-point exception flags.
+*----------------------------------------------------------------------------*/
+extern signed char float_exception_flags;
+enum {
+    float_flag_invalid   =  1,
+    float_flag_divbyzero =  4,
+    float_flag_overflow  =  8,
+    float_flag_underflow = 16,
+    float_flag_inexact   = 32
+};
+
+/*----------------------------------------------------------------------------
+| Routine to raise any or all of the software IEC/IEEE floating-point
+| exception flags.
+*----------------------------------------------------------------------------*/
+void float_raise( signed char );
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE integer-to-floating-point conversion routines.
+*----------------------------------------------------------------------------*/
+float32 int32_to_float32( int );
+float64 int32_to_float64( int );
+#ifdef FLOATX80
+floatx80 int32_to_floatx80( int );
+#endif
+#ifdef FLOAT128
+float128 int32_to_float128( int );
+#endif
+float32 int64_to_float32( long long );
+float64 int64_to_float64( long long );
+#ifdef FLOATX80
+floatx80 int64_to_floatx80( long long );
+#endif
+#ifdef FLOAT128
+float128 int64_to_float128( long long );
+#endif
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE single-precision conversion routines.
+*----------------------------------------------------------------------------*/
+int float32_to_int32( float32 );
+int float32_to_int32_round_to_zero( float32 );
+long long float32_to_int64( float32 );
+long long float32_to_int64_round_to_zero( float32 );
+float64 float32_to_float64( float32 );
+#ifdef FLOATX80
+floatx80 float32_to_floatx80( float32 );
+#endif
+#ifdef FLOAT128
+float128 float32_to_float128( float32 );
+#endif
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE single-precision operations.
+*----------------------------------------------------------------------------*/
+float32 float32_round_to_int( float32 );
+float32 float32_add( float32, float32 );
+float32 float32_sub( float32, float32 );
+float32 float32_mul( float32, float32 );
+float32 float32_div( float32, float32 );
+float32 float32_rem( float32, float32 );
+float32 float32_sqrt( float32 );
+char float32_eq( float32, float32 );
+char float32_le( float32, float32 );
+char float32_lt( float32, float32 );
+char float32_eq_signaling( float32, float32 );
+char float32_le_quiet( float32, float32 );
+char float32_lt_quiet( float32, float32 );
+char float32_is_signaling_nan( float32 );
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE double-precision conversion routines.
+*----------------------------------------------------------------------------*/
+int float64_to_int32( float64 );
+int float64_to_int32_round_to_zero( float64 );
+long long float64_to_int64( float64 );
+long long float64_to_int64_round_to_zero( float64 );
+float32 float64_to_float32( float64 );
+#ifdef FLOATX80
+floatx80 float64_to_floatx80( float64 );
+#endif
+#ifdef FLOAT128
+float128 float64_to_float128( float64 );
+#endif
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE double-precision operations.
+*----------------------------------------------------------------------------*/
+float64 float64_round_to_int( float64 );
+float64 float64_add( float64, float64 );
+float64 float64_sub( float64, float64 );
+float64 float64_mul( float64, float64 );
+float64 float64_div( float64, float64 );
+float64 float64_rem( float64, float64 );
+float64 float64_sqrt( float64 );
+char float64_eq( float64, float64 );
+char float64_le( float64, float64 );
+char float64_lt( float64, float64 );
+char float64_eq_signaling( float64, float64 );
+char float64_le_quiet( float64, float64 );
+char float64_lt_quiet( float64, float64 );
+char float64_is_signaling_nan( float64 );
+
+#ifdef FLOATX80
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE extended double-precision conversion routines.
+*----------------------------------------------------------------------------*/
+int floatx80_to_int32( floatx80 );
+int floatx80_to_int32_round_to_zero( floatx80 );
+long long floatx80_to_int64( floatx80 );
+long long floatx80_to_int64_round_to_zero( floatx80 );
+float32 floatx80_to_float32( floatx80 );
+float64 floatx80_to_float64( floatx80 );
+#ifdef FLOAT128
+float128 floatx80_to_float128( floatx80 );
+#endif
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE extended double-precision rounding precision.  Valid
+| values are 32, 64, and 80.
+*----------------------------------------------------------------------------*/
+extern signed char floatx80_rounding_precision;
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE extended double-precision operations.
+*----------------------------------------------------------------------------*/
+floatx80 floatx80_round_to_int( floatx80 );
+floatx80 floatx80_add( floatx80, floatx80 );
+floatx80 floatx80_sub( floatx80, floatx80 );
+floatx80 floatx80_mul( floatx80, floatx80 );
+floatx80 floatx80_div( floatx80, floatx80 );
+floatx80 floatx80_rem( floatx80, floatx80 );
+floatx80 floatx80_sqrt( floatx80 );
+char floatx80_eq( floatx80, floatx80 );
+char floatx80_le( floatx80, floatx80 );
+char floatx80_lt( floatx80, floatx80 );
+char floatx80_eq_signaling( floatx80, floatx80 );
+char floatx80_le_quiet( floatx80, floatx80 );
+char floatx80_lt_quiet( floatx80, floatx80 );
+char floatx80_is_signaling_nan( floatx80 );
+
+#endif
+
+#ifdef FLOAT128
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE quadruple-precision conversion routines.
+*----------------------------------------------------------------------------*/
+int float128_to_int32( float128 );
+int float128_to_int32_round_to_zero( float128 );
+long long float128_to_int64( float128 );
+long long float128_to_int64_round_to_zero( float128 );
+float32 float128_to_float32( float128 );
+float64 float128_to_float64( float128 );
+#ifdef FLOATX80
+floatx80 float128_to_floatx80( float128 );
+#endif
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE quadruple-precision operations.
+*----------------------------------------------------------------------------*/
+float128 float128_round_to_int( float128 );
+float128 float128_add( float128, float128 );
+float128 float128_sub( float128, float128 );
+float128 float128_mul( float128, float128 );
+float128 float128_div( float128, float128 );
+float128 float128_rem( float128, float128 );
+float128 float128_sqrt( float128 );
+char float128_eq( float128, float128 );
+char float128_le( float128, float128 );
+char float128_lt( float128, float128 );
+char float128_eq_signaling( float128, float128 );
+char float128_le_quiet( float128, float128 );
+char float128_lt_quiet( float128, float128 );
+char float128_is_signaling_nan( float128 );
+
+#endif
+
diff -urN TestFloat-2a/softfloat/bits64/386-Win32-gcc/softfloat-specialize testfloat/softfloat/bits64/386-Win32-gcc/softfloat-specialize
--- TestFloat-2a/softfloat/bits64/386-Win32-gcc/softfloat-specialize	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/softfloat/bits64/386-Win32-gcc/softfloat-specialize	2008-08-17 09:46:53.000000000 +0200
@@ -0,0 +1,464 @@
+
+/*============================================================================
+
+This C source fragment is part of the SoftFloat IEC/IEEE Floating-point
+Arithmetic Package, Release 2b.
+
+Written by John R. Hauser.  This work was made possible in part by the
+International Computer Science Institute, located at Suite 600, 1947 Center
+Street, Berkeley, California 94704.  Funding was partially provided by the
+National Science Foundation under grant MIP-9311980.  The original version
+of this code was written as part of a project to build a fixed-point vector
+processor in collaboration with the University of California at Berkeley,
+overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
+is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
+arithmetic/SoftFloat.html'.
+
+THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
+been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
+RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
+AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
+COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
+EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
+INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
+OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.
+
+Derivative works are acceptable, even for commercial purposes, so long as
+(1) the source code for the derivative work includes prominent notice that
+the work is derivative, and (2) the source code includes prominent notice with
+these four paragraphs for those parts of this code that are retained.
+
+=============================================================================*/
+
+/*----------------------------------------------------------------------------
+| Underflow tininess-detection mode, statically initialized to default value.
+| (The declaration in `softfloat.h' must match the `int8' type here.)
+*----------------------------------------------------------------------------*/
+int8 float_detect_tininess = float_tininess_after_rounding;
+
+/*----------------------------------------------------------------------------
+| Raises the exceptions specified by `flags'.  Floating-point traps can be
+| defined here if desired.  It is currently not possible for such a trap
+| to substitute a result value.  If traps are not implemented, this routine
+| should be simply `float_exception_flags |= flags;'.
+*----------------------------------------------------------------------------*/
+
+void float_raise( int8 flags )
+{
+
+    float_exception_flags |= flags;
+
+}
+
+/*----------------------------------------------------------------------------
+| Internal canonical NaN format.
+*----------------------------------------------------------------------------*/
+typedef struct {
+    flag sign;
+    bits64 high, low;
+} commonNaNT;
+
+/*----------------------------------------------------------------------------
+| The pattern for a default generated single-precision NaN.
+*----------------------------------------------------------------------------*/
+#define float32_default_nan 0xFFC00000
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the single-precision floating-point value `a' is a NaN;
+| otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag float32_is_nan( float32 a )
+{
+
+    return ( 0xFF000000 < (bits32) ( a<<1 ) );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the single-precision floating-point value `a' is a signaling
+| NaN; otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag float32_is_signaling_nan( float32 a )
+{
+
+    return ( ( ( a>>22 ) & 0x1FF ) == 0x1FE ) && ( a & 0x003FFFFF );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the single-precision floating-point NaN
+| `a' to the canonical NaN format.  If `a' is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+
+static commonNaNT float32ToCommonNaN( float32 a )
+{
+    commonNaNT z;
+
+    if ( float32_is_signaling_nan( a ) ) float_raise( float_flag_invalid );
+    z.sign = a>>31;
+    z.low = 0;
+    z.high = ( (bits64) a )<<41;
+    return z;
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the canonical NaN `a' to the single-
+| precision floating-point format.
+*----------------------------------------------------------------------------*/
+
+static float32 commonNaNToFloat32( commonNaNT a )
+{
+
+    return ( ( (bits32) a.sign )<<31 ) | 0x7FC00000 | ( a.high>>41 );
+
+}
+
+/*----------------------------------------------------------------------------
+| Takes two single-precision floating-point values `a' and `b', one of which
+| is a NaN, and returns the appropriate NaN result.  If either `a' or `b' is a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+
+static float32 propagateFloat32NaN( float32 a, float32 b )
+{
+    flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;
+
+    aIsNaN = float32_is_nan( a );
+    aIsSignalingNaN = float32_is_signaling_nan( a );
+    bIsNaN = float32_is_nan( b );
+    bIsSignalingNaN = float32_is_signaling_nan( b );
+    a |= 0x00400000;
+    b |= 0x00400000;
+    if ( aIsSignalingNaN | bIsSignalingNaN ) float_raise( float_flag_invalid );
+    if ( aIsSignalingNaN ) {
+        if ( bIsSignalingNaN ) goto returnLargerSignificand;
+        return bIsNaN ? b : a;
+    }
+    else if ( aIsNaN ) {
+        if ( bIsSignalingNaN | ! bIsNaN ) return a;
+ returnLargerSignificand:
+        if ( (bits32) ( a<<1 ) < (bits32) ( b<<1 ) ) return b;
+        if ( (bits32) ( b<<1 ) < (bits32) ( a<<1 ) ) return a;
+        return ( a < b ) ? a : b;
+    }
+    else {
+        return b;
+    }
+
+}
+
+/*----------------------------------------------------------------------------
+| The pattern for a default generated double-precision NaN.
+*----------------------------------------------------------------------------*/
+#define float64_default_nan LIT64( 0xFFF8000000000000 )
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the double-precision floating-point value `a' is a NaN;
+| otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag float64_is_nan( float64 a )
+{
+
+    return ( LIT64( 0xFFE0000000000000 ) < (bits64) ( a<<1 ) );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the double-precision floating-point value `a' is a signaling
+| NaN; otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag float64_is_signaling_nan( float64 a )
+{
+
+    return
+           ( ( ( a>>51 ) & 0xFFF ) == 0xFFE )
+        && ( a & LIT64( 0x0007FFFFFFFFFFFF ) );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the double-precision floating-point NaN
+| `a' to the canonical NaN format.  If `a' is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+
+static commonNaNT float64ToCommonNaN( float64 a )
+{
+    commonNaNT z;
+
+    if ( float64_is_signaling_nan( a ) ) float_raise( float_flag_invalid );
+    z.sign = a>>63;
+    z.low = 0;
+    z.high = a<<12;
+    return z;
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the canonical NaN `a' to the double-
+| precision floating-point format.
+*----------------------------------------------------------------------------*/
+
+static float64 commonNaNToFloat64( commonNaNT a )
+{
+
+    return
+          ( ( (bits64) a.sign )<<63 )
+        | LIT64( 0x7FF8000000000000 )
+        | ( a.high>>12 );
+
+}
+
+/*----------------------------------------------------------------------------
+| Takes two double-precision floating-point values `a' and `b', one of which
+| is a NaN, and returns the appropriate NaN result.  If either `a' or `b' is a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+
+static float64 propagateFloat64NaN( float64 a, float64 b )
+{
+    flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;
+
+    aIsNaN = float64_is_nan( a );
+    aIsSignalingNaN = float64_is_signaling_nan( a );
+    bIsNaN = float64_is_nan( b );
+    bIsSignalingNaN = float64_is_signaling_nan( b );
+    a |= LIT64( 0x0008000000000000 );
+    b |= LIT64( 0x0008000000000000 );
+    if ( aIsSignalingNaN | bIsSignalingNaN ) float_raise( float_flag_invalid );
+    if ( aIsSignalingNaN ) {
+        if ( bIsSignalingNaN ) goto returnLargerSignificand;
+        return bIsNaN ? b : a;
+    }
+    else if ( aIsNaN ) {
+        if ( bIsSignalingNaN | ! bIsNaN ) return a;
+ returnLargerSignificand:
+        if ( (bits64) ( a<<1 ) < (bits64) ( b<<1 ) ) return b;
+        if ( (bits64) ( b<<1 ) < (bits64) ( a<<1 ) ) return a;
+        return ( a < b ) ? a : b;
+    }
+    else {
+        return b;
+    }
+
+}
+
+#ifdef FLOATX80
+
+/*----------------------------------------------------------------------------
+| The pattern for a default generated extended double-precision NaN.  The
+| `high' and `low' values hold the most- and least-significant bits,
+| respectively.
+*----------------------------------------------------------------------------*/
+#define floatx80_default_nan_high 0xFFFF
+#define floatx80_default_nan_low  LIT64( 0xC000000000000000 )
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the extended double-precision floating-point value `a' is a
+| NaN; otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag floatx80_is_nan( floatx80 a )
+{
+
+    return ( ( a.high & 0x7FFF ) == 0x7FFF ) && (bits64) ( a.low<<1 );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the extended double-precision floating-point value `a' is a
+| signaling NaN; otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag floatx80_is_signaling_nan( floatx80 a )
+{
+    bits64 aLow;
+
+    aLow = a.low & ~ LIT64( 0x4000000000000000 );
+    return
+           ( ( a.high & 0x7FFF ) == 0x7FFF )
+        && (bits64) ( aLow<<1 )
+        && ( a.low == aLow );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the extended double-precision floating-
+| point NaN `a' to the canonical NaN format.  If `a' is a signaling NaN, the
+| invalid exception is raised.
+*----------------------------------------------------------------------------*/
+
+static commonNaNT floatx80ToCommonNaN( floatx80 a )
+{
+    commonNaNT z;
+
+    if ( floatx80_is_signaling_nan( a ) ) float_raise( float_flag_invalid );
+    z.sign = a.high>>15;
+    z.low = 0;
+    z.high = a.low<<1;
+    return z;
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the canonical NaN `a' to the extended
+| double-precision floating-point format.
+*----------------------------------------------------------------------------*/
+
+static floatx80 commonNaNToFloatx80( commonNaNT a )
+{
+    floatx80 z;
+
+    z.low = LIT64( 0xC000000000000000 ) | ( a.high>>1 );
+    z.high = ( ( (bits16) a.sign )<<15 ) | 0x7FFF;
+    return z;
+
+}
+
+/*----------------------------------------------------------------------------
+| Takes two extended double-precision floating-point values `a' and `b', one
+| of which is a NaN, and returns the appropriate NaN result.  If either `a' or
+| `b' is a signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+
+static floatx80 propagateFloatx80NaN( floatx80 a, floatx80 b )
+{
+    flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;
+
+    aIsNaN = floatx80_is_nan( a );
+    aIsSignalingNaN = floatx80_is_signaling_nan( a );
+    bIsNaN = floatx80_is_nan( b );
+    bIsSignalingNaN = floatx80_is_signaling_nan( b );
+    a.low |= LIT64( 0xC000000000000000 );
+    b.low |= LIT64( 0xC000000000000000 );
+    if ( aIsSignalingNaN | bIsSignalingNaN ) float_raise( float_flag_invalid );
+    if ( aIsSignalingNaN ) {
+        if ( bIsSignalingNaN ) goto returnLargerSignificand;
+        return bIsNaN ? b : a;
+    }
+    else if ( aIsNaN ) {
+        if ( bIsSignalingNaN | ! bIsNaN ) return a;
+ returnLargerSignificand:
+        if ( a.low < b.low ) return b;
+        if ( b.low < a.low ) return a;
+        return ( a.high < b.high ) ? a : b;
+    }
+    else {
+        return b;
+    }
+
+}
+
+#endif
+
+#ifdef FLOAT128
+
+/*----------------------------------------------------------------------------
+| The pattern for a default generated quadruple-precision NaN.  The `high' and
+| `low' values hold the most- and least-significant bits, respectively.
+*----------------------------------------------------------------------------*/
+#define float128_default_nan_high LIT64( 0xFFFF800000000000 )
+#define float128_default_nan_low  LIT64( 0x0000000000000000 )
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the quadruple-precision floating-point value `a' is a NaN;
+| otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag float128_is_nan( float128 a )
+{
+
+    return
+           ( LIT64( 0xFFFE000000000000 ) <= (bits64) ( a.high<<1 ) )
+        && ( a.low || ( a.high & LIT64( 0x0000FFFFFFFFFFFF ) ) );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the quadruple-precision floating-point value `a' is a
+| signaling NaN; otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag float128_is_signaling_nan( float128 a )
+{
+
+    return
+           ( ( ( a.high>>47 ) & 0xFFFF ) == 0xFFFE )
+        && ( a.low || ( a.high & LIT64( 0x00007FFFFFFFFFFF ) ) );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the quadruple-precision floating-point NaN
+| `a' to the canonical NaN format.  If `a' is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+
+static commonNaNT float128ToCommonNaN( float128 a )
+{
+    commonNaNT z;
+
+    if ( float128_is_signaling_nan( a ) ) float_raise( float_flag_invalid );
+    z.sign = a.high>>63;
+    shortShift128Left( a.high, a.low, 16, &z.high, &z.low );
+    return z;
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the canonical NaN `a' to the quadruple-
+| precision floating-point format.
+*----------------------------------------------------------------------------*/
+
+static float128 commonNaNToFloat128( commonNaNT a )
+{
+    float128 z;
+
+    shift128Right( a.high, a.low, 16, &z.high, &z.low );
+    z.high |= ( ( (bits64) a.sign )<<63 ) | LIT64( 0x7FFF800000000000 );
+    return z;
+
+}
+
+/*----------------------------------------------------------------------------
+| Takes two quadruple-precision floating-point values `a' and `b', one of
+| which is a NaN, and returns the appropriate NaN result.  If either `a' or
+| `b' is a signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+
+static float128 propagateFloat128NaN( float128 a, float128 b )
+{
+    flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;
+
+    aIsNaN = float128_is_nan( a );
+    aIsSignalingNaN = float128_is_signaling_nan( a );
+    bIsNaN = float128_is_nan( b );
+    bIsSignalingNaN = float128_is_signaling_nan( b );
+    a.high |= LIT64( 0x0000800000000000 );
+    b.high |= LIT64( 0x0000800000000000 );
+    if ( aIsSignalingNaN | bIsSignalingNaN ) float_raise( float_flag_invalid );
+    if ( aIsSignalingNaN ) {
+        if ( bIsSignalingNaN ) goto returnLargerSignificand;
+        return bIsNaN ? b : a;
+    }
+    else if ( aIsNaN ) {
+        if ( bIsSignalingNaN | ! bIsNaN ) return a;
+ returnLargerSignificand:
+        if ( lt128( a.high<<1, a.low, b.high<<1, b.low ) ) return b;
+        if ( lt128( b.high<<1, b.low, a.high<<1, a.low ) ) return a;
+        return ( a.high < b.high ) ? a : b;
+    }
+    else {
+        return b;
+    }
+
+}
+
+#endif
+
diff -urN TestFloat-2a/softfloat/bits64/386-Win32-GCC/Makefile testfloat/softfloat/bits64/386-Win32-GCC/Makefile
--- TestFloat-2a/softfloat/bits64/386-Win32-GCC/Makefile	2002-05-28 02:33:28.000000000 +0200
+++ testfloat/softfloat/bits64/386-Win32-GCC/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,24 +0,0 @@
-
-PROCESSOR_H = ../../../processors/386-GCC.h
-SOFTFLOAT_MACROS = ../softfloat-macros
-
-OBJ = .o
-EXE = .exe
-INCLUDES = -I. -I..
-COMPILE_C = gcc -c -o $@ $(INCLUDES) -I- -O2
-LINK = gcc -o $@
-
-ALL: softfloat$(OBJ) timesoftfloat$(EXE)
-
-milieu.h: $(PROCESSOR_H)
-	touch milieu.h
-
-softfloat$(OBJ): milieu.h softfloat.h softfloat-specialize $(SOFTFLOAT_MACROS) ../softfloat.c
-	$(COMPILE_C) ../softfloat.c
-
-timesoftfloat$(OBJ): milieu.h softfloat.h ../timesoftfloat.c
-	$(COMPILE_C) ../timesoftfloat.c
-
-timesoftfloat$(EXE): softfloat$(OBJ) timesoftfloat$(OBJ)
-	$(LINK) softfloat$(OBJ) timesoftfloat$(OBJ)
-
diff -urN TestFloat-2a/softfloat/bits64/386-Win32-GCC/milieu.h testfloat/softfloat/bits64/386-Win32-GCC/milieu.h
--- TestFloat-2a/softfloat/bits64/386-Win32-GCC/milieu.h	2002-05-28 02:33:28.000000000 +0200
+++ testfloat/softfloat/bits64/386-Win32-GCC/milieu.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,45 +0,0 @@
-
-/*============================================================================
-
-This C header file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic
-Package, Release 2b.
-
-Written by John R. Hauser.  This work was made possible in part by the
-International Computer Science Institute, located at Suite 600, 1947 Center
-Street, Berkeley, California 94704.  Funding was partially provided by the
-National Science Foundation under grant MIP-9311980.  The original version
-of this code was written as part of a project to build a fixed-point vector
-processor in collaboration with the University of California at Berkeley,
-overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
-is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
-arithmetic/SoftFloat.html'.
-
-THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
-been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
-RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
-AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
-COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
-EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
-INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
-OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.
-
-Derivative works are acceptable, even for commercial purposes, so long as
-(1) the source code for the derivative work includes prominent notice that
-the work is derivative, and (2) the source code includes prominent notice with
-these four paragraphs for those parts of this code that are retained.
-
-=============================================================================*/
-
-/*----------------------------------------------------------------------------
-| Include common integer types and flags.
-*----------------------------------------------------------------------------*/
-#include "../../../processors/386-GCC.h"
-
-/*----------------------------------------------------------------------------
-| Symbolic Boolean literals.
-*----------------------------------------------------------------------------*/
-enum {
-    FALSE = 0,
-    TRUE  = 1
-};
-
diff -urN TestFloat-2a/softfloat/bits64/386-Win32-GCC/softfloat.h testfloat/softfloat/bits64/386-Win32-GCC/softfloat.h
--- TestFloat-2a/softfloat/bits64/386-Win32-GCC/softfloat.h	2002-05-28 02:33:28.000000000 +0200
+++ testfloat/softfloat/bits64/386-Win32-GCC/softfloat.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,259 +0,0 @@
-
-/*============================================================================
-
-This C header file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic
-Package, Release 2b.
-
-Written by John R. Hauser.  This work was made possible in part by the
-International Computer Science Institute, located at Suite 600, 1947 Center
-Street, Berkeley, California 94704.  Funding was partially provided by the
-National Science Foundation under grant MIP-9311980.  The original version
-of this code was written as part of a project to build a fixed-point vector
-processor in collaboration with the University of California at Berkeley,
-overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
-is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
-arithmetic/SoftFloat.html'.
-
-THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
-been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
-RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
-AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
-COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
-EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
-INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
-OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.
-
-Derivative works are acceptable, even for commercial purposes, so long as
-(1) the source code for the derivative work includes prominent notice that
-the work is derivative, and (2) the source code includes prominent notice with
-these four paragraphs for those parts of this code that are retained.
-
-=============================================================================*/
-
-/*----------------------------------------------------------------------------
-| The macro `FLOATX80' must be defined to enable the extended double-precision
-| floating-point format `floatx80'.  If this macro is not defined, the
-| `floatx80' type will not be defined, and none of the functions that either
-| input or output the `floatx80' type will be defined.  The same applies to
-| the `FLOAT128' macro and the quadruple-precision format `float128'.
-*----------------------------------------------------------------------------*/
-#define FLOATX80
-#define FLOAT128
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE floating-point types.
-*----------------------------------------------------------------------------*/
-typedef unsigned int float32;
-typedef unsigned long long float64;
-#ifdef FLOATX80
-typedef struct {
-    unsigned long long low;
-    unsigned short high;
-} floatx80;
-#endif
-#ifdef FLOAT128
-typedef struct {
-    unsigned long long low, high;
-} float128;
-#endif
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE floating-point underflow tininess-detection mode.
-*----------------------------------------------------------------------------*/
-extern signed char float_detect_tininess;
-enum {
-    float_tininess_after_rounding  = 0,
-    float_tininess_before_rounding = 1
-};
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE floating-point rounding mode.
-*----------------------------------------------------------------------------*/
-extern signed char float_rounding_mode;
-enum {
-    float_round_nearest_even = 0,
-    float_round_down         = 1,
-    float_round_up           = 2,
-    float_round_to_zero      = 3
-};
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE floating-point exception flags.
-*----------------------------------------------------------------------------*/
-extern signed char float_exception_flags;
-enum {
-    float_flag_invalid   =  1,
-    float_flag_divbyzero =  4,
-    float_flag_overflow  =  8,
-    float_flag_underflow = 16,
-    float_flag_inexact   = 32
-};
-
-/*----------------------------------------------------------------------------
-| Routine to raise any or all of the software IEC/IEEE floating-point
-| exception flags.
-*----------------------------------------------------------------------------*/
-void float_raise( signed char );
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE integer-to-floating-point conversion routines.
-*----------------------------------------------------------------------------*/
-float32 int32_to_float32( int );
-float64 int32_to_float64( int );
-#ifdef FLOATX80
-floatx80 int32_to_floatx80( int );
-#endif
-#ifdef FLOAT128
-float128 int32_to_float128( int );
-#endif
-float32 int64_to_float32( long long );
-float64 int64_to_float64( long long );
-#ifdef FLOATX80
-floatx80 int64_to_floatx80( long long );
-#endif
-#ifdef FLOAT128
-float128 int64_to_float128( long long );
-#endif
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE single-precision conversion routines.
-*----------------------------------------------------------------------------*/
-int float32_to_int32( float32 );
-int float32_to_int32_round_to_zero( float32 );
-long long float32_to_int64( float32 );
-long long float32_to_int64_round_to_zero( float32 );
-float64 float32_to_float64( float32 );
-#ifdef FLOATX80
-floatx80 float32_to_floatx80( float32 );
-#endif
-#ifdef FLOAT128
-float128 float32_to_float128( float32 );
-#endif
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE single-precision operations.
-*----------------------------------------------------------------------------*/
-float32 float32_round_to_int( float32 );
-float32 float32_add( float32, float32 );
-float32 float32_sub( float32, float32 );
-float32 float32_mul( float32, float32 );
-float32 float32_div( float32, float32 );
-float32 float32_rem( float32, float32 );
-float32 float32_sqrt( float32 );
-char float32_eq( float32, float32 );
-char float32_le( float32, float32 );
-char float32_lt( float32, float32 );
-char float32_eq_signaling( float32, float32 );
-char float32_le_quiet( float32, float32 );
-char float32_lt_quiet( float32, float32 );
-char float32_is_signaling_nan( float32 );
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE double-precision conversion routines.
-*----------------------------------------------------------------------------*/
-int float64_to_int32( float64 );
-int float64_to_int32_round_to_zero( float64 );
-long long float64_to_int64( float64 );
-long long float64_to_int64_round_to_zero( float64 );
-float32 float64_to_float32( float64 );
-#ifdef FLOATX80
-floatx80 float64_to_floatx80( float64 );
-#endif
-#ifdef FLOAT128
-float128 float64_to_float128( float64 );
-#endif
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE double-precision operations.
-*----------------------------------------------------------------------------*/
-float64 float64_round_to_int( float64 );
-float64 float64_add( float64, float64 );
-float64 float64_sub( float64, float64 );
-float64 float64_mul( float64, float64 );
-float64 float64_div( float64, float64 );
-float64 float64_rem( float64, float64 );
-float64 float64_sqrt( float64 );
-char float64_eq( float64, float64 );
-char float64_le( float64, float64 );
-char float64_lt( float64, float64 );
-char float64_eq_signaling( float64, float64 );
-char float64_le_quiet( float64, float64 );
-char float64_lt_quiet( float64, float64 );
-char float64_is_signaling_nan( float64 );
-
-#ifdef FLOATX80
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE extended double-precision conversion routines.
-*----------------------------------------------------------------------------*/
-int floatx80_to_int32( floatx80 );
-int floatx80_to_int32_round_to_zero( floatx80 );
-long long floatx80_to_int64( floatx80 );
-long long floatx80_to_int64_round_to_zero( floatx80 );
-float32 floatx80_to_float32( floatx80 );
-float64 floatx80_to_float64( floatx80 );
-#ifdef FLOAT128
-float128 floatx80_to_float128( floatx80 );
-#endif
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE extended double-precision rounding precision.  Valid
-| values are 32, 64, and 80.
-*----------------------------------------------------------------------------*/
-extern signed char floatx80_rounding_precision;
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE extended double-precision operations.
-*----------------------------------------------------------------------------*/
-floatx80 floatx80_round_to_int( floatx80 );
-floatx80 floatx80_add( floatx80, floatx80 );
-floatx80 floatx80_sub( floatx80, floatx80 );
-floatx80 floatx80_mul( floatx80, floatx80 );
-floatx80 floatx80_div( floatx80, floatx80 );
-floatx80 floatx80_rem( floatx80, floatx80 );
-floatx80 floatx80_sqrt( floatx80 );
-char floatx80_eq( floatx80, floatx80 );
-char floatx80_le( floatx80, floatx80 );
-char floatx80_lt( floatx80, floatx80 );
-char floatx80_eq_signaling( floatx80, floatx80 );
-char floatx80_le_quiet( floatx80, floatx80 );
-char floatx80_lt_quiet( floatx80, floatx80 );
-char floatx80_is_signaling_nan( floatx80 );
-
-#endif
-
-#ifdef FLOAT128
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE quadruple-precision conversion routines.
-*----------------------------------------------------------------------------*/
-int float128_to_int32( float128 );
-int float128_to_int32_round_to_zero( float128 );
-long long float128_to_int64( float128 );
-long long float128_to_int64_round_to_zero( float128 );
-float32 float128_to_float32( float128 );
-float64 float128_to_float64( float128 );
-#ifdef FLOATX80
-floatx80 float128_to_floatx80( float128 );
-#endif
-
-/*----------------------------------------------------------------------------
-| Software IEC/IEEE quadruple-precision operations.
-*----------------------------------------------------------------------------*/
-float128 float128_round_to_int( float128 );
-float128 float128_add( float128, float128 );
-float128 float128_sub( float128, float128 );
-float128 float128_mul( float128, float128 );
-float128 float128_div( float128, float128 );
-float128 float128_rem( float128, float128 );
-float128 float128_sqrt( float128 );
-char float128_eq( float128, float128 );
-char float128_le( float128, float128 );
-char float128_lt( float128, float128 );
-char float128_eq_signaling( float128, float128 );
-char float128_le_quiet( float128, float128 );
-char float128_lt_quiet( float128, float128 );
-char float128_is_signaling_nan( float128 );
-
-#endif
-
diff -urN TestFloat-2a/softfloat/bits64/386-Win32-GCC/softfloat-specialize testfloat/softfloat/bits64/386-Win32-GCC/softfloat-specialize
--- TestFloat-2a/softfloat/bits64/386-Win32-GCC/softfloat-specialize	2002-05-28 02:33:28.000000000 +0200
+++ testfloat/softfloat/bits64/386-Win32-GCC/softfloat-specialize	1970-01-01 01:00:00.000000000 +0100
@@ -1,464 +0,0 @@
-
-/*============================================================================
-
-This C source fragment is part of the SoftFloat IEC/IEEE Floating-point
-Arithmetic Package, Release 2b.
-
-Written by John R. Hauser.  This work was made possible in part by the
-International Computer Science Institute, located at Suite 600, 1947 Center
-Street, Berkeley, California 94704.  Funding was partially provided by the
-National Science Foundation under grant MIP-9311980.  The original version
-of this code was written as part of a project to build a fixed-point vector
-processor in collaboration with the University of California at Berkeley,
-overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
-is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
-arithmetic/SoftFloat.html'.
-
-THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
-been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
-RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
-AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
-COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
-EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
-INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
-OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.
-
-Derivative works are acceptable, even for commercial purposes, so long as
-(1) the source code for the derivative work includes prominent notice that
-the work is derivative, and (2) the source code includes prominent notice with
-these four paragraphs for those parts of this code that are retained.
-
-=============================================================================*/
-
-/*----------------------------------------------------------------------------
-| Underflow tininess-detection mode, statically initialized to default value.
-| (The declaration in `softfloat.h' must match the `int8' type here.)
-*----------------------------------------------------------------------------*/
-int8 float_detect_tininess = float_tininess_after_rounding;
-
-/*----------------------------------------------------------------------------
-| Raises the exceptions specified by `flags'.  Floating-point traps can be
-| defined here if desired.  It is currently not possible for such a trap
-| to substitute a result value.  If traps are not implemented, this routine
-| should be simply `float_exception_flags |= flags;'.
-*----------------------------------------------------------------------------*/
-
-void float_raise( int8 flags )
-{
-
-    float_exception_flags |= flags;
-
-}
-
-/*----------------------------------------------------------------------------
-| Internal canonical NaN format.
-*----------------------------------------------------------------------------*/
-typedef struct {
-    flag sign;
-    bits64 high, low;
-} commonNaNT;
-
-/*----------------------------------------------------------------------------
-| The pattern for a default generated single-precision NaN.
-*----------------------------------------------------------------------------*/
-#define float32_default_nan 0xFFC00000
-
-/*----------------------------------------------------------------------------
-| Returns 1 if the single-precision floating-point value `a' is a NaN;
-| otherwise returns 0.
-*----------------------------------------------------------------------------*/
-
-flag float32_is_nan( float32 a )
-{
-
-    return ( 0xFF000000 < (bits32) ( a<<1 ) );
-
-}
-
-/*----------------------------------------------------------------------------
-| Returns 1 if the single-precision floating-point value `a' is a signaling
-| NaN; otherwise returns 0.
-*----------------------------------------------------------------------------*/
-
-flag float32_is_signaling_nan( float32 a )
-{
-
-    return ( ( ( a>>22 ) & 0x1FF ) == 0x1FE ) && ( a & 0x003FFFFF );
-
-}
-
-/*----------------------------------------------------------------------------
-| Returns the result of converting the single-precision floating-point NaN
-| `a' to the canonical NaN format.  If `a' is a signaling NaN, the invalid
-| exception is raised.
-*----------------------------------------------------------------------------*/
-
-static commonNaNT float32ToCommonNaN( float32 a )
-{
-    commonNaNT z;
-
-    if ( float32_is_signaling_nan( a ) ) float_raise( float_flag_invalid );
-    z.sign = a>>31;
-    z.low = 0;
-    z.high = ( (bits64) a )<<41;
-    return z;
-
-}
-
-/*----------------------------------------------------------------------------
-| Returns the result of converting the canonical NaN `a' to the single-
-| precision floating-point format.
-*----------------------------------------------------------------------------*/
-
-static float32 commonNaNToFloat32( commonNaNT a )
-{
-
-    return ( ( (bits32) a.sign )<<31 ) | 0x7FC00000 | ( a.high>>41 );
-
-}
-
-/*----------------------------------------------------------------------------
-| Takes two single-precision floating-point values `a' and `b', one of which
-| is a NaN, and returns the appropriate NaN result.  If either `a' or `b' is a
-| signaling NaN, the invalid exception is raised.
-*----------------------------------------------------------------------------*/
-
-static float32 propagateFloat32NaN( float32 a, float32 b )
-{
-    flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;
-
-    aIsNaN = float32_is_nan( a );
-    aIsSignalingNaN = float32_is_signaling_nan( a );
-    bIsNaN = float32_is_nan( b );
-    bIsSignalingNaN = float32_is_signaling_nan( b );
-    a |= 0x00400000;
-    b |= 0x00400000;
-    if ( aIsSignalingNaN | bIsSignalingNaN ) float_raise( float_flag_invalid );
-    if ( aIsSignalingNaN ) {
-        if ( bIsSignalingNaN ) goto returnLargerSignificand;
-        return bIsNaN ? b : a;
-    }
-    else if ( aIsNaN ) {
-        if ( bIsSignalingNaN | ! bIsNaN ) return a;
- returnLargerSignificand:
-        if ( (bits32) ( a<<1 ) < (bits32) ( b<<1 ) ) return b;
-        if ( (bits32) ( b<<1 ) < (bits32) ( a<<1 ) ) return a;
-        return ( a < b ) ? a : b;
-    }
-    else {
-        return b;
-    }
-
-}
-
-/*----------------------------------------------------------------------------
-| The pattern for a default generated double-precision NaN.
-*----------------------------------------------------------------------------*/
-#define float64_default_nan LIT64( 0xFFF8000000000000 )
-
-/*----------------------------------------------------------------------------
-| Returns 1 if the double-precision floating-point value `a' is a NaN;
-| otherwise returns 0.
-*----------------------------------------------------------------------------*/
-
-flag float64_is_nan( float64 a )
-{
-
-    return ( LIT64( 0xFFE0000000000000 ) < (bits64) ( a<<1 ) );
-
-}
-
-/*----------------------------------------------------------------------------
-| Returns 1 if the double-precision floating-point value `a' is a signaling
-| NaN; otherwise returns 0.
-*----------------------------------------------------------------------------*/
-
-flag float64_is_signaling_nan( float64 a )
-{
-
-    return
-           ( ( ( a>>51 ) & 0xFFF ) == 0xFFE )
-        && ( a & LIT64( 0x0007FFFFFFFFFFFF ) );
-
-}
-
-/*----------------------------------------------------------------------------
-| Returns the result of converting the double-precision floating-point NaN
-| `a' to the canonical NaN format.  If `a' is a signaling NaN, the invalid
-| exception is raised.
-*----------------------------------------------------------------------------*/
-
-static commonNaNT float64ToCommonNaN( float64 a )
-{
-    commonNaNT z;
-
-    if ( float64_is_signaling_nan( a ) ) float_raise( float_flag_invalid );
-    z.sign = a>>63;
-    z.low = 0;
-    z.high = a<<12;
-    return z;
-
-}
-
-/*----------------------------------------------------------------------------
-| Returns the result of converting the canonical NaN `a' to the double-
-| precision floating-point format.
-*----------------------------------------------------------------------------*/
-
-static float64 commonNaNToFloat64( commonNaNT a )
-{
-
-    return
-          ( ( (bits64) a.sign )<<63 )
-        | LIT64( 0x7FF8000000000000 )
-        | ( a.high>>12 );
-
-}
-
-/*----------------------------------------------------------------------------
-| Takes two double-precision floating-point values `a' and `b', one of which
-| is a NaN, and returns the appropriate NaN result.  If either `a' or `b' is a
-| signaling NaN, the invalid exception is raised.
-*----------------------------------------------------------------------------*/
-
-static float64 propagateFloat64NaN( float64 a, float64 b )
-{
-    flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;
-
-    aIsNaN = float64_is_nan( a );
-    aIsSignalingNaN = float64_is_signaling_nan( a );
-    bIsNaN = float64_is_nan( b );
-    bIsSignalingNaN = float64_is_signaling_nan( b );
-    a |= LIT64( 0x0008000000000000 );
-    b |= LIT64( 0x0008000000000000 );
-    if ( aIsSignalingNaN | bIsSignalingNaN ) float_raise( float_flag_invalid );
-    if ( aIsSignalingNaN ) {
-        if ( bIsSignalingNaN ) goto returnLargerSignificand;
-        return bIsNaN ? b : a;
-    }
-    else if ( aIsNaN ) {
-        if ( bIsSignalingNaN | ! bIsNaN ) return a;
- returnLargerSignificand:
-        if ( (bits64) ( a<<1 ) < (bits64) ( b<<1 ) ) return b;
-        if ( (bits64) ( b<<1 ) < (bits64) ( a<<1 ) ) return a;
-        return ( a < b ) ? a : b;
-    }
-    else {
-        return b;
-    }
-
-}
-
-#ifdef FLOATX80
-
-/*----------------------------------------------------------------------------
-| The pattern for a default generated extended double-precision NaN.  The
-| `high' and `low' values hold the most- and least-significant bits,
-| respectively.
-*----------------------------------------------------------------------------*/
-#define floatx80_default_nan_high 0xFFFF
-#define floatx80_default_nan_low  LIT64( 0xC000000000000000 )
-
-/*----------------------------------------------------------------------------
-| Returns 1 if the extended double-precision floating-point value `a' is a
-| NaN; otherwise returns 0.
-*----------------------------------------------------------------------------*/
-
-flag floatx80_is_nan( floatx80 a )
-{
-
-    return ( ( a.high & 0x7FFF ) == 0x7FFF ) && (bits64) ( a.low<<1 );
-
-}
-
-/*----------------------------------------------------------------------------
-| Returns 1 if the extended double-precision floating-point value `a' is a
-| signaling NaN; otherwise returns 0.
-*----------------------------------------------------------------------------*/
-
-flag floatx80_is_signaling_nan( floatx80 a )
-{
-    bits64 aLow;
-
-    aLow = a.low & ~ LIT64( 0x4000000000000000 );
-    return
-           ( ( a.high & 0x7FFF ) == 0x7FFF )
-        && (bits64) ( aLow<<1 )
-        && ( a.low == aLow );
-
-}
-
-/*----------------------------------------------------------------------------
-| Returns the result of converting the extended double-precision floating-
-| point NaN `a' to the canonical NaN format.  If `a' is a signaling NaN, the
-| invalid exception is raised.
-*----------------------------------------------------------------------------*/
-
-static commonNaNT floatx80ToCommonNaN( floatx80 a )
-{
-    commonNaNT z;
-
-    if ( floatx80_is_signaling_nan( a ) ) float_raise( float_flag_invalid );
-    z.sign = a.high>>15;
-    z.low = 0;
-    z.high = a.low<<1;
-    return z;
-
-}
-
-/*----------------------------------------------------------------------------
-| Returns the result of converting the canonical NaN `a' to the extended
-| double-precision floating-point format.
-*----------------------------------------------------------------------------*/
-
-static floatx80 commonNaNToFloatx80( commonNaNT a )
-{
-    floatx80 z;
-
-    z.low = LIT64( 0xC000000000000000 ) | ( a.high>>1 );
-    z.high = ( ( (bits16) a.sign )<<15 ) | 0x7FFF;
-    return z;
-
-}
-
-/*----------------------------------------------------------------------------
-| Takes two extended double-precision floating-point values `a' and `b', one
-| of which is a NaN, and returns the appropriate NaN result.  If either `a' or
-| `b' is a signaling NaN, the invalid exception is raised.
-*----------------------------------------------------------------------------*/
-
-static floatx80 propagateFloatx80NaN( floatx80 a, floatx80 b )
-{
-    flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;
-
-    aIsNaN = floatx80_is_nan( a );
-    aIsSignalingNaN = floatx80_is_signaling_nan( a );
-    bIsNaN = floatx80_is_nan( b );
-    bIsSignalingNaN = floatx80_is_signaling_nan( b );
-    a.low |= LIT64( 0xC000000000000000 );
-    b.low |= LIT64( 0xC000000000000000 );
-    if ( aIsSignalingNaN | bIsSignalingNaN ) float_raise( float_flag_invalid );
-    if ( aIsSignalingNaN ) {
-        if ( bIsSignalingNaN ) goto returnLargerSignificand;
-        return bIsNaN ? b : a;
-    }
-    else if ( aIsNaN ) {
-        if ( bIsSignalingNaN | ! bIsNaN ) return a;
- returnLargerSignificand:
-        if ( a.low < b.low ) return b;
-        if ( b.low < a.low ) return a;
-        return ( a.high < b.high ) ? a : b;
-    }
-    else {
-        return b;
-    }
-
-}
-
-#endif
-
-#ifdef FLOAT128
-
-/*----------------------------------------------------------------------------
-| The pattern for a default generated quadruple-precision NaN.  The `high' and
-| `low' values hold the most- and least-significant bits, respectively.
-*----------------------------------------------------------------------------*/
-#define float128_default_nan_high LIT64( 0xFFFF800000000000 )
-#define float128_default_nan_low  LIT64( 0x0000000000000000 )
-
-/*----------------------------------------------------------------------------
-| Returns 1 if the quadruple-precision floating-point value `a' is a NaN;
-| otherwise returns 0.
-*----------------------------------------------------------------------------*/
-
-flag float128_is_nan( float128 a )
-{
-
-    return
-           ( LIT64( 0xFFFE000000000000 ) <= (bits64) ( a.high<<1 ) )
-        && ( a.low || ( a.high & LIT64( 0x0000FFFFFFFFFFFF ) ) );
-
-}
-
-/*----------------------------------------------------------------------------
-| Returns 1 if the quadruple-precision floating-point value `a' is a
-| signaling NaN; otherwise returns 0.
-*----------------------------------------------------------------------------*/
-
-flag float128_is_signaling_nan( float128 a )
-{
-
-    return
-           ( ( ( a.high>>47 ) & 0xFFFF ) == 0xFFFE )
-        && ( a.low || ( a.high & LIT64( 0x00007FFFFFFFFFFF ) ) );
-
-}
-
-/*----------------------------------------------------------------------------
-| Returns the result of converting the quadruple-precision floating-point NaN
-| `a' to the canonical NaN format.  If `a' is a signaling NaN, the invalid
-| exception is raised.
-*----------------------------------------------------------------------------*/
-
-static commonNaNT float128ToCommonNaN( float128 a )
-{
-    commonNaNT z;
-
-    if ( float128_is_signaling_nan( a ) ) float_raise( float_flag_invalid );
-    z.sign = a.high>>63;
-    shortShift128Left( a.high, a.low, 16, &z.high, &z.low );
-    return z;
-
-}
-
-/*----------------------------------------------------------------------------
-| Returns the result of converting the canonical NaN `a' to the quadruple-
-| precision floating-point format.
-*----------------------------------------------------------------------------*/
-
-static float128 commonNaNToFloat128( commonNaNT a )
-{
-    float128 z;
-
-    shift128Right( a.high, a.low, 16, &z.high, &z.low );
-    z.high |= ( ( (bits64) a.sign )<<63 ) | LIT64( 0x7FFF800000000000 );
-    return z;
-
-}
-
-/*----------------------------------------------------------------------------
-| Takes two quadruple-precision floating-point values `a' and `b', one of
-| which is a NaN, and returns the appropriate NaN result.  If either `a' or
-| `b' is a signaling NaN, the invalid exception is raised.
-*----------------------------------------------------------------------------*/
-
-static float128 propagateFloat128NaN( float128 a, float128 b )
-{
-    flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;
-
-    aIsNaN = float128_is_nan( a );
-    aIsSignalingNaN = float128_is_signaling_nan( a );
-    bIsNaN = float128_is_nan( b );
-    bIsSignalingNaN = float128_is_signaling_nan( b );
-    a.high |= LIT64( 0x0000800000000000 );
-    b.high |= LIT64( 0x0000800000000000 );
-    if ( aIsSignalingNaN | bIsSignalingNaN ) float_raise( float_flag_invalid );
-    if ( aIsSignalingNaN ) {
-        if ( bIsSignalingNaN ) goto returnLargerSignificand;
-        return bIsNaN ? b : a;
-    }
-    else if ( aIsNaN ) {
-        if ( bIsSignalingNaN | ! bIsNaN ) return a;
- returnLargerSignificand:
-        if ( lt128( a.high<<1, a.low, b.high<<1, b.low ) ) return b;
-        if ( lt128( b.high<<1, b.low, a.high<<1, a.low ) ) return a;
-        return ( a.high < b.high ) ? a : b;
-    }
-    else {
-        return b;
-    }
-
-}
-
-#endif
-
diff -urN TestFloat-2a/softfloat/bits64/arm-linux-gcc/Makefile testfloat/softfloat/bits64/arm-linux-gcc/Makefile
--- TestFloat-2a/softfloat/bits64/arm-linux-gcc/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/softfloat/bits64/arm-linux-gcc/Makefile	2013-12-02 17:57:51.196482866 +0100
@@ -0,0 +1,27 @@
+
+PROCESSOR_H = ../../../processors/arm-gcc.h
+SOFTFLOAT_MACROS = ../softfloat-macros
+
+OBJ = .o
+EXE = .exe
+INCLUDES = -I. -I..
+COMPILE_C = $(CROSS_COMPILE)gcc -c -o $@ $(INCLUDES) -I- -O2
+LINK = $(CROSS_COMPILE)gcc -o $@
+
+all: softfloat$(OBJ) timesoftfloat$(EXE)
+
+milieu.h: $(PROCESSOR_H)
+	touch milieu.h
+
+softfloat$(OBJ): milieu.h softfloat.h softfloat-specialize $(SOFTFLOAT_MACROS) ../softfloat.c
+	$(COMPILE_C) ../softfloat.c
+
+timesoftfloat$(OBJ): milieu.h softfloat.h ../timesoftfloat.c
+	$(COMPILE_C) ../timesoftfloat.c
+
+timesoftfloat$(EXE): softfloat$(OBJ) timesoftfloat$(OBJ)
+	$(LINK) softfloat$(OBJ) timesoftfloat$(OBJ)
+
+clean: 
+	rm *.o
+	rm *.exe
diff -urN TestFloat-2a/softfloat/bits64/arm-linux-gcc/milieu.h testfloat/softfloat/bits64/arm-linux-gcc/milieu.h
--- TestFloat-2a/softfloat/bits64/arm-linux-gcc/milieu.h	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/softfloat/bits64/arm-linux-gcc/milieu.h	2008-08-17 09:46:53.000000000 +0200
@@ -0,0 +1,45 @@
+
+/*============================================================================
+
+This C header file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic
+Package, Release 2b.
+
+Written by John R. Hauser.  This work was made possible in part by the
+International Computer Science Institute, located at Suite 600, 1947 Center
+Street, Berkeley, California 94704.  Funding was partially provided by the
+National Science Foundation under grant MIP-9311980.  The original version
+of this code was written as part of a project to build a fixed-point vector
+processor in collaboration with the University of California at Berkeley,
+overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
+is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
+arithmetic/SoftFloat.html'.
+
+THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
+been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
+RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
+AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
+COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
+EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
+INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
+OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.
+
+Derivative works are acceptable, even for commercial purposes, so long as
+(1) the source code for the derivative work includes prominent notice that
+the work is derivative, and (2) the source code includes prominent notice with
+these four paragraphs for those parts of this code that are retained.
+
+=============================================================================*/
+
+/*----------------------------------------------------------------------------
+| Include common integer types and flags.
+*----------------------------------------------------------------------------*/
+#include "../../../processors/386-gcc.h"
+
+/*----------------------------------------------------------------------------
+| Symbolic Boolean literals.
+*----------------------------------------------------------------------------*/
+enum {
+    FALSE = 0,
+    TRUE  = 1
+};
+
diff -urN TestFloat-2a/softfloat/bits64/arm-linux-gcc/softfloat.h testfloat/softfloat/bits64/arm-linux-gcc/softfloat.h
--- TestFloat-2a/softfloat/bits64/arm-linux-gcc/softfloat.h	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/softfloat/bits64/arm-linux-gcc/softfloat.h	2008-08-17 09:46:53.000000000 +0200
@@ -0,0 +1,260 @@
+
+/*============================================================================
+
+This C header file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic
+Package, Release 2b.
+
+Written by John R. Hauser.  This work was made possible in part by the
+International Computer Science Institute, located at Suite 600, 1947 Center
+Street, Berkeley, California 94704.  Funding was partially provided by the
+National Science Foundation under grant MIP-9311980.  The original version
+of this code was written as part of a project to build a fixed-point vector
+processor in collaboration with the University of California at Berkeley,
+overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
+is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
+arithmetic/SoftFloat.html'.
+
+THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
+been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
+RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
+AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
+COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
+EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
+INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
+OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.
+
+Derivative works are acceptable, even for commercial purposes, so long as
+(1) the source code for the derivative work includes prominent notice that
+the work is derivative, and (2) the source code includes prominent notice with
+these four paragraphs for those parts of this code that are retained.
+
+=============================================================================*/
+
+/*----------------------------------------------------------------------------
+| The macro `FLOATX80' must be defined to enable the extended double-precision
+| floating-point format `floatx80'.  If this macro is not defined, the
+| `floatx80' type will not be defined, and none of the functions that either
+| input or output the `floatx80' type will be defined.  The same applies to
+| the `FLOAT128' macro and the quadruple-precision format `float128'.
+*----------------------------------------------------------------------------*/
+
+#define FLOATX80
+#define FLOAT128
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE floating-point types.
+*----------------------------------------------------------------------------*/
+typedef unsigned int float32;
+typedef unsigned long long float64;
+#ifdef FLOATX80
+typedef struct {
+    unsigned long long low;
+    unsigned short high;
+} floatx80;
+#endif
+#ifdef FLOAT128
+typedef struct {
+    unsigned long long low, high;
+} float128;
+#endif
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE floating-point underflow tininess-detection mode.
+*----------------------------------------------------------------------------*/
+extern signed char float_detect_tininess;
+enum {
+    float_tininess_after_rounding  = 0,
+    float_tininess_before_rounding = 1
+};
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE floating-point rounding mode.
+*----------------------------------------------------------------------------*/
+extern signed char float_rounding_mode;
+enum {
+    float_round_nearest_even = 0,
+    float_round_down         = 1,
+    float_round_up           = 2,
+    float_round_to_zero      = 3
+};
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE floating-point exception flags.
+*----------------------------------------------------------------------------*/
+extern signed char float_exception_flags;
+enum {
+    float_flag_invalid   =  1,
+    float_flag_divbyzero =  4,
+    float_flag_overflow  =  8,
+    float_flag_underflow = 16,
+    float_flag_inexact   = 32
+};
+
+/*----------------------------------------------------------------------------
+| Routine to raise any or all of the software IEC/IEEE floating-point
+| exception flags.
+*----------------------------------------------------------------------------*/
+void float_raise( signed char );
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE integer-to-floating-point conversion routines.
+*----------------------------------------------------------------------------*/
+float32 int32_to_float32( int );
+float64 int32_to_float64( int );
+#ifdef FLOATX80
+floatx80 int32_to_floatx80( int );
+#endif
+#ifdef FLOAT128
+float128 int32_to_float128( int );
+#endif
+float32 int64_to_float32( long long );
+float64 int64_to_float64( long long );
+#ifdef FLOATX80
+floatx80 int64_to_floatx80( long long );
+#endif
+#ifdef FLOAT128
+float128 int64_to_float128( long long );
+#endif
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE single-precision conversion routines.
+*----------------------------------------------------------------------------*/
+int float32_to_int32( float32 );
+int float32_to_int32_round_to_zero( float32 );
+long long float32_to_int64( float32 );
+long long float32_to_int64_round_to_zero( float32 );
+float64 float32_to_float64( float32 );
+#ifdef FLOATX80
+floatx80 float32_to_floatx80( float32 );
+#endif
+#ifdef FLOAT128
+float128 float32_to_float128( float32 );
+#endif
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE single-precision operations.
+*----------------------------------------------------------------------------*/
+float32 float32_round_to_int( float32 );
+float32 float32_add( float32, float32 );
+float32 float32_sub( float32, float32 );
+float32 float32_mul( float32, float32 );
+float32 float32_div( float32, float32 );
+float32 float32_rem( float32, float32 );
+float32 float32_sqrt( float32 );
+char float32_eq( float32, float32 );
+char float32_le( float32, float32 );
+char float32_lt( float32, float32 );
+char float32_eq_signaling( float32, float32 );
+char float32_le_quiet( float32, float32 );
+char float32_lt_quiet( float32, float32 );
+char float32_is_signaling_nan( float32 );
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE double-precision conversion routines.
+*----------------------------------------------------------------------------*/
+int float64_to_int32( float64 );
+int float64_to_int32_round_to_zero( float64 );
+long long float64_to_int64( float64 );
+long long float64_to_int64_round_to_zero( float64 );
+float32 float64_to_float32( float64 );
+#ifdef FLOATX80
+floatx80 float64_to_floatx80( float64 );
+#endif
+#ifdef FLOAT128
+float128 float64_to_float128( float64 );
+#endif
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE double-precision operations.
+*----------------------------------------------------------------------------*/
+float64 float64_round_to_int( float64 );
+float64 float64_add( float64, float64 );
+float64 float64_sub( float64, float64 );
+float64 float64_mul( float64, float64 );
+float64 float64_div( float64, float64 );
+float64 float64_rem( float64, float64 );
+float64 float64_sqrt( float64 );
+char float64_eq( float64, float64 );
+char float64_le( float64, float64 );
+char float64_lt( float64, float64 );
+char float64_eq_signaling( float64, float64 );
+char float64_le_quiet( float64, float64 );
+char float64_lt_quiet( float64, float64 );
+char float64_is_signaling_nan( float64 );
+
+#ifdef FLOATX80
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE extended double-precision conversion routines.
+*----------------------------------------------------------------------------*/
+int floatx80_to_int32( floatx80 );
+int floatx80_to_int32_round_to_zero( floatx80 );
+long long floatx80_to_int64( floatx80 );
+long long floatx80_to_int64_round_to_zero( floatx80 );
+float32 floatx80_to_float32( floatx80 );
+float64 floatx80_to_float64( floatx80 );
+#ifdef FLOAT128
+float128 floatx80_to_float128( floatx80 );
+#endif
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE extended double-precision rounding precision.  Valid
+| values are 32, 64, and 80.
+*----------------------------------------------------------------------------*/
+extern signed char floatx80_rounding_precision;
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE extended double-precision operations.
+*----------------------------------------------------------------------------*/
+floatx80 floatx80_round_to_int( floatx80 );
+floatx80 floatx80_add( floatx80, floatx80 );
+floatx80 floatx80_sub( floatx80, floatx80 );
+floatx80 floatx80_mul( floatx80, floatx80 );
+floatx80 floatx80_div( floatx80, floatx80 );
+floatx80 floatx80_rem( floatx80, floatx80 );
+floatx80 floatx80_sqrt( floatx80 );
+char floatx80_eq( floatx80, floatx80 );
+char floatx80_le( floatx80, floatx80 );
+char floatx80_lt( floatx80, floatx80 );
+char floatx80_eq_signaling( floatx80, floatx80 );
+char floatx80_le_quiet( floatx80, floatx80 );
+char floatx80_lt_quiet( floatx80, floatx80 );
+char floatx80_is_signaling_nan( floatx80 );
+
+#endif
+
+#ifdef FLOAT128
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE quadruple-precision conversion routines.
+*----------------------------------------------------------------------------*/
+int float128_to_int32( float128 );
+int float128_to_int32_round_to_zero( float128 );
+long long float128_to_int64( float128 );
+long long float128_to_int64_round_to_zero( float128 );
+float32 float128_to_float32( float128 );
+float64 float128_to_float64( float128 );
+#ifdef FLOATX80
+floatx80 float128_to_floatx80( float128 );
+#endif
+
+/*----------------------------------------------------------------------------
+| Software IEC/IEEE quadruple-precision operations.
+*----------------------------------------------------------------------------*/
+float128 float128_round_to_int( float128 );
+float128 float128_add( float128, float128 );
+float128 float128_sub( float128, float128 );
+float128 float128_mul( float128, float128 );
+float128 float128_div( float128, float128 );
+float128 float128_rem( float128, float128 );
+float128 float128_sqrt( float128 );
+char float128_eq( float128, float128 );
+char float128_le( float128, float128 );
+char float128_lt( float128, float128 );
+char float128_eq_signaling( float128, float128 );
+char float128_le_quiet( float128, float128 );
+char float128_lt_quiet( float128, float128 );
+char float128_is_signaling_nan( float128 );
+
+#endif
+
diff -urN TestFloat-2a/softfloat/bits64/arm-linux-gcc/softfloat-specialize testfloat/softfloat/bits64/arm-linux-gcc/softfloat-specialize
--- TestFloat-2a/softfloat/bits64/arm-linux-gcc/softfloat-specialize	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/softfloat/bits64/arm-linux-gcc/softfloat-specialize	2008-08-17 09:46:53.000000000 +0200
@@ -0,0 +1,464 @@
+
+/*============================================================================
+
+This C source fragment is part of the SoftFloat IEC/IEEE Floating-point
+Arithmetic Package, Release 2b.
+
+Written by John R. Hauser.  This work was made possible in part by the
+International Computer Science Institute, located at Suite 600, 1947 Center
+Street, Berkeley, California 94704.  Funding was partially provided by the
+National Science Foundation under grant MIP-9311980.  The original version
+of this code was written as part of a project to build a fixed-point vector
+processor in collaboration with the University of California at Berkeley,
+overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
+is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
+arithmetic/SoftFloat.html'.
+
+THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
+been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
+RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
+AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
+COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
+EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
+INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
+OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.
+
+Derivative works are acceptable, even for commercial purposes, so long as
+(1) the source code for the derivative work includes prominent notice that
+the work is derivative, and (2) the source code includes prominent notice with
+these four paragraphs for those parts of this code that are retained.
+
+=============================================================================*/
+
+/*----------------------------------------------------------------------------
+| Underflow tininess-detection mode, statically initialized to default value.
+| (The declaration in `softfloat.h' must match the `int8' type here.)
+*----------------------------------------------------------------------------*/
+int8 float_detect_tininess = float_tininess_after_rounding;
+
+/*----------------------------------------------------------------------------
+| Raises the exceptions specified by `flags'.  Floating-point traps can be
+| defined here if desired.  It is currently not possible for such a trap
+| to substitute a result value.  If traps are not implemented, this routine
+| should be simply `float_exception_flags |= flags;'.
+*----------------------------------------------------------------------------*/
+
+void float_raise( int8 flags )
+{
+
+    float_exception_flags |= flags;
+
+}
+
+/*----------------------------------------------------------------------------
+| Internal canonical NaN format.
+*----------------------------------------------------------------------------*/
+typedef struct {
+    flag sign;
+    bits64 high, low;
+} commonNaNT;
+
+/*----------------------------------------------------------------------------
+| The pattern for a default generated single-precision NaN.
+*----------------------------------------------------------------------------*/
+#define float32_default_nan 0xFFC00000
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the single-precision floating-point value `a' is a NaN;
+| otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag float32_is_nan( float32 a )
+{
+
+    return ( 0xFF000000 < (bits32) ( a<<1 ) );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the single-precision floating-point value `a' is a signaling
+| NaN; otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag float32_is_signaling_nan( float32 a )
+{
+
+    return ( ( ( a>>22 ) & 0x1FF ) == 0x1FE ) && ( a & 0x003FFFFF );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the single-precision floating-point NaN
+| `a' to the canonical NaN format.  If `a' is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+
+static commonNaNT float32ToCommonNaN( float32 a )
+{
+    commonNaNT z;
+
+    if ( float32_is_signaling_nan( a ) ) float_raise( float_flag_invalid );
+    z.sign = a>>31;
+    z.low = 0;
+    z.high = ( (bits64) a )<<41;
+    return z;
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the canonical NaN `a' to the single-
+| precision floating-point format.
+*----------------------------------------------------------------------------*/
+
+static float32 commonNaNToFloat32( commonNaNT a )
+{
+
+    return ( ( (bits32) a.sign )<<31 ) | 0x7FC00000 | ( a.high>>41 );
+
+}
+
+/*----------------------------------------------------------------------------
+| Takes two single-precision floating-point values `a' and `b', one of which
+| is a NaN, and returns the appropriate NaN result.  If either `a' or `b' is a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+
+static float32 propagateFloat32NaN( float32 a, float32 b )
+{
+    flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;
+
+    aIsNaN = float32_is_nan( a );
+    aIsSignalingNaN = float32_is_signaling_nan( a );
+    bIsNaN = float32_is_nan( b );
+    bIsSignalingNaN = float32_is_signaling_nan( b );
+    a |= 0x00400000;
+    b |= 0x00400000;
+    if ( aIsSignalingNaN | bIsSignalingNaN ) float_raise( float_flag_invalid );
+    if ( aIsSignalingNaN ) {
+        if ( bIsSignalingNaN ) goto returnLargerSignificand;
+        return bIsNaN ? b : a;
+    }
+    else if ( aIsNaN ) {
+        if ( bIsSignalingNaN | ! bIsNaN ) return a;
+ returnLargerSignificand:
+        if ( (bits32) ( a<<1 ) < (bits32) ( b<<1 ) ) return b;
+        if ( (bits32) ( b<<1 ) < (bits32) ( a<<1 ) ) return a;
+        return ( a < b ) ? a : b;
+    }
+    else {
+        return b;
+    }
+
+}
+
+/*----------------------------------------------------------------------------
+| The pattern for a default generated double-precision NaN.
+*----------------------------------------------------------------------------*/
+#define float64_default_nan LIT64( 0xFFF8000000000000 )
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the double-precision floating-point value `a' is a NaN;
+| otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag float64_is_nan( float64 a )
+{
+
+    return ( LIT64( 0xFFE0000000000000 ) < (bits64) ( a<<1 ) );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the double-precision floating-point value `a' is a signaling
+| NaN; otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag float64_is_signaling_nan( float64 a )
+{
+
+    return
+           ( ( ( a>>51 ) & 0xFFF ) == 0xFFE )
+        && ( a & LIT64( 0x0007FFFFFFFFFFFF ) );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the double-precision floating-point NaN
+| `a' to the canonical NaN format.  If `a' is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+
+static commonNaNT float64ToCommonNaN( float64 a )
+{
+    commonNaNT z;
+
+    if ( float64_is_signaling_nan( a ) ) float_raise( float_flag_invalid );
+    z.sign = a>>63;
+    z.low = 0;
+    z.high = a<<12;
+    return z;
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the canonical NaN `a' to the double-
+| precision floating-point format.
+*----------------------------------------------------------------------------*/
+
+static float64 commonNaNToFloat64( commonNaNT a )
+{
+
+    return
+          ( ( (bits64) a.sign )<<63 )
+        | LIT64( 0x7FF8000000000000 )
+        | ( a.high>>12 );
+
+}
+
+/*----------------------------------------------------------------------------
+| Takes two double-precision floating-point values `a' and `b', one of which
+| is a NaN, and returns the appropriate NaN result.  If either `a' or `b' is a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+
+static float64 propagateFloat64NaN( float64 a, float64 b )
+{
+    flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;
+
+    aIsNaN = float64_is_nan( a );
+    aIsSignalingNaN = float64_is_signaling_nan( a );
+    bIsNaN = float64_is_nan( b );
+    bIsSignalingNaN = float64_is_signaling_nan( b );
+    a |= LIT64( 0x0008000000000000 );
+    b |= LIT64( 0x0008000000000000 );
+    if ( aIsSignalingNaN | bIsSignalingNaN ) float_raise( float_flag_invalid );
+    if ( aIsSignalingNaN ) {
+        if ( bIsSignalingNaN ) goto returnLargerSignificand;
+        return bIsNaN ? b : a;
+    }
+    else if ( aIsNaN ) {
+        if ( bIsSignalingNaN | ! bIsNaN ) return a;
+ returnLargerSignificand:
+        if ( (bits64) ( a<<1 ) < (bits64) ( b<<1 ) ) return b;
+        if ( (bits64) ( b<<1 ) < (bits64) ( a<<1 ) ) return a;
+        return ( a < b ) ? a : b;
+    }
+    else {
+        return b;
+    }
+
+}
+
+#ifdef FLOATX80
+
+/*----------------------------------------------------------------------------
+| The pattern for a default generated extended double-precision NaN.  The
+| `high' and `low' values hold the most- and least-significant bits,
+| respectively.
+*----------------------------------------------------------------------------*/
+#define floatx80_default_nan_high 0xFFFF
+#define floatx80_default_nan_low  LIT64( 0xC000000000000000 )
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the extended double-precision floating-point value `a' is a
+| NaN; otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag floatx80_is_nan( floatx80 a )
+{
+
+    return ( ( a.high & 0x7FFF ) == 0x7FFF ) && (bits64) ( a.low<<1 );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the extended double-precision floating-point value `a' is a
+| signaling NaN; otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag floatx80_is_signaling_nan( floatx80 a )
+{
+    bits64 aLow;
+
+    aLow = a.low & ~ LIT64( 0x4000000000000000 );
+    return
+           ( ( a.high & 0x7FFF ) == 0x7FFF )
+        && (bits64) ( aLow<<1 )
+        && ( a.low == aLow );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the extended double-precision floating-
+| point NaN `a' to the canonical NaN format.  If `a' is a signaling NaN, the
+| invalid exception is raised.
+*----------------------------------------------------------------------------*/
+
+static commonNaNT floatx80ToCommonNaN( floatx80 a )
+{
+    commonNaNT z;
+
+    if ( floatx80_is_signaling_nan( a ) ) float_raise( float_flag_invalid );
+    z.sign = a.high>>15;
+    z.low = 0;
+    z.high = a.low<<1;
+    return z;
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the canonical NaN `a' to the extended
+| double-precision floating-point format.
+*----------------------------------------------------------------------------*/
+
+static floatx80 commonNaNToFloatx80( commonNaNT a )
+{
+    floatx80 z;
+
+    z.low = LIT64( 0xC000000000000000 ) | ( a.high>>1 );
+    z.high = ( ( (bits16) a.sign )<<15 ) | 0x7FFF;
+    return z;
+
+}
+
+/*----------------------------------------------------------------------------
+| Takes two extended double-precision floating-point values `a' and `b', one
+| of which is a NaN, and returns the appropriate NaN result.  If either `a' or
+| `b' is a signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+
+static floatx80 propagateFloatx80NaN( floatx80 a, floatx80 b )
+{
+    flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;
+
+    aIsNaN = floatx80_is_nan( a );
+    aIsSignalingNaN = floatx80_is_signaling_nan( a );
+    bIsNaN = floatx80_is_nan( b );
+    bIsSignalingNaN = floatx80_is_signaling_nan( b );
+    a.low |= LIT64( 0xC000000000000000 );
+    b.low |= LIT64( 0xC000000000000000 );
+    if ( aIsSignalingNaN | bIsSignalingNaN ) float_raise( float_flag_invalid );
+    if ( aIsSignalingNaN ) {
+        if ( bIsSignalingNaN ) goto returnLargerSignificand;
+        return bIsNaN ? b : a;
+    }
+    else if ( aIsNaN ) {
+        if ( bIsSignalingNaN | ! bIsNaN ) return a;
+ returnLargerSignificand:
+        if ( a.low < b.low ) return b;
+        if ( b.low < a.low ) return a;
+        return ( a.high < b.high ) ? a : b;
+    }
+    else {
+        return b;
+    }
+
+}
+
+#endif
+
+#ifdef FLOAT128
+
+/*----------------------------------------------------------------------------
+| The pattern for a default generated quadruple-precision NaN.  The `high' and
+| `low' values hold the most- and least-significant bits, respectively.
+*----------------------------------------------------------------------------*/
+#define float128_default_nan_high LIT64( 0xFFFF800000000000 )
+#define float128_default_nan_low  LIT64( 0x0000000000000000 )
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the quadruple-precision floating-point value `a' is a NaN;
+| otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag float128_is_nan( float128 a )
+{
+
+    return
+           ( LIT64( 0xFFFE000000000000 ) <= (bits64) ( a.high<<1 ) )
+        && ( a.low || ( a.high & LIT64( 0x0000FFFFFFFFFFFF ) ) );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns 1 if the quadruple-precision floating-point value `a' is a
+| signaling NaN; otherwise returns 0.
+*----------------------------------------------------------------------------*/
+
+flag float128_is_signaling_nan( float128 a )
+{
+
+    return
+           ( ( ( a.high>>47 ) & 0xFFFF ) == 0xFFFE )
+        && ( a.low || ( a.high & LIT64( 0x00007FFFFFFFFFFF ) ) );
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the quadruple-precision floating-point NaN
+| `a' to the canonical NaN format.  If `a' is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+
+static commonNaNT float128ToCommonNaN( float128 a )
+{
+    commonNaNT z;
+
+    if ( float128_is_signaling_nan( a ) ) float_raise( float_flag_invalid );
+    z.sign = a.high>>63;
+    shortShift128Left( a.high, a.low, 16, &z.high, &z.low );
+    return z;
+
+}
+
+/*----------------------------------------------------------------------------
+| Returns the result of converting the canonical NaN `a' to the quadruple-
+| precision floating-point format.
+*----------------------------------------------------------------------------*/
+
+static float128 commonNaNToFloat128( commonNaNT a )
+{
+    float128 z;
+
+    shift128Right( a.high, a.low, 16, &z.high, &z.low );
+    z.high |= ( ( (bits64) a.sign )<<63 ) | LIT64( 0x7FFF800000000000 );
+    return z;
+
+}
+
+/*----------------------------------------------------------------------------
+| Takes two quadruple-precision floating-point values `a' and `b', one of
+| which is a NaN, and returns the appropriate NaN result.  If either `a' or
+| `b' is a signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+
+static float128 propagateFloat128NaN( float128 a, float128 b )
+{
+    flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;
+
+    aIsNaN = float128_is_nan( a );
+    aIsSignalingNaN = float128_is_signaling_nan( a );
+    bIsNaN = float128_is_nan( b );
+    bIsSignalingNaN = float128_is_signaling_nan( b );
+    a.high |= LIT64( 0x0000800000000000 );
+    b.high |= LIT64( 0x0000800000000000 );
+    if ( aIsSignalingNaN | bIsSignalingNaN ) float_raise( float_flag_invalid );
+    if ( aIsSignalingNaN ) {
+        if ( bIsSignalingNaN ) goto returnLargerSignificand;
+        return bIsNaN ? b : a;
+    }
+    else if ( aIsNaN ) {
+        if ( bIsSignalingNaN | ! bIsNaN ) return a;
+ returnLargerSignificand:
+        if ( lt128( a.high<<1, a.low, b.high<<1, b.low ) ) return b;
+        if ( lt128( b.high<<1, b.low, a.high<<1, a.low ) ) return a;
+        return ( a.high < b.high ) ? a : b;
+    }
+    else {
+        return b;
+    }
+
+}
+
+#endif
+
diff -urN TestFloat-2a/softfloat/bits64/timesoftfloat.c testfloat/softfloat/bits64/timesoftfloat.c
--- TestFloat-2a/softfloat/bits64/timesoftfloat.c	2002-05-27 00:16:50.000000000 +0200
+++ testfloat/softfloat/bits64/timesoftfloat.c	2008-08-17 09:46:53.000000000 +0200
@@ -145,7 +145,6 @@
 }
 
 #ifdef FLOATX80
-
 static void time_a_int32_z_floatx80( floatx80 function( int32 ) )
 {
     clock_t startClock, endClock;
diff -urN TestFloat-2a/testfloat/386-Win32-gcc/milieu.h testfloat/testfloat/386-Win32-gcc/milieu.h
--- TestFloat-2a/testfloat/386-Win32-gcc/milieu.h	1998-12-18 08:20:08.000000000 +0100
+++ testfloat/testfloat/386-Win32-gcc/milieu.h	2008-08-17 09:46:52.000000000 +0200
@@ -38,6 +38,7 @@
 -------------------------------------------------------------------------------
 #undef BITS64
 */
+#define BITS64
 
 /*
 -------------------------------------------------------------------------------
diff -urN TestFloat-2a/testfloat/386-Win32-gcc/systflags.S testfloat/testfloat/386-Win32-gcc/systflags.S
--- TestFloat-2a/testfloat/386-Win32-gcc/systflags.S	1998-12-14 07:07:39.000000000 +0100
+++ testfloat/testfloat/386-Win32-gcc/systflags.S	2008-08-17 09:46:52.000000000 +0200
@@ -32,8 +32,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 2
-.globl _syst_float_flags_clear
-_syst_float_flags_clear:
+.globl syst_float_flags_clear
+syst_float_flags_clear:
 	fnstsw %ax
 	fnclex
 	andl $61,%eax
diff -urN TestFloat-2a/testfloat/386-Win32-gcc/systfloat.S testfloat/testfloat/386-Win32-gcc/systfloat.S
--- TestFloat-2a/testfloat/386-Win32-gcc/systfloat.S	1998-12-18 08:12:35.000000000 +0100
+++ testfloat/testfloat/386-Win32-gcc/systfloat.S	2008-08-17 09:46:52.000000000 +0200
@@ -30,8 +30,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 2
-.globl _syst_int32_to_floatx80
-_syst_int32_to_floatx80:
+.globl syst_int32_to_floatx80
+syst_int32_to_floatx80:
 	fildl 8(%esp)
 	movl 4(%esp),%eax
 	fstpt (%eax)
@@ -42,8 +42,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 2
-.globl _syst_int64_to_floatx80
-_syst_int64_to_floatx80:
+.globl syst_int64_to_floatx80
+syst_int64_to_floatx80:
 	fildq 8(%esp)
 	movl 4(%esp),%eax
 	fstpt (%eax)
@@ -54,8 +54,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 2
-.globl _syst_float32_to_floatx80
-_syst_float32_to_floatx80:
+.globl syst_float32_to_floatx80
+syst_float32_to_floatx80:
 	flds 8(%esp)
 	movl 4(%esp),%eax
 	fstpt (%eax)
@@ -66,8 +66,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 2
-.globl _syst_float64_to_floatx80
-_syst_float64_to_floatx80:
+.globl syst_float64_to_floatx80
+syst_float64_to_floatx80:
 	fldl 8(%esp)
 	movl 4(%esp),%eax
 	fstpt (%eax)
@@ -78,8 +78,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 2
-.globl _syst_floatx80_to_int32
-_syst_floatx80_to_int32:
+.globl syst_floatx80_to_int32
+syst_floatx80_to_int32:
 	fldt 4(%esp)
 	subl $4,%esp
 	fistpl (%esp)
@@ -92,8 +92,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 2
-.globl _syst_floatx80_to_int64
-_syst_floatx80_to_int64:
+.globl syst_floatx80_to_int64
+syst_floatx80_to_int64:
 	fldt 4(%esp)
 	subl $8,%esp
 	fistpq (%esp)
@@ -107,8 +107,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 2
-.globl _syst_floatx80_to_float32
-_syst_floatx80_to_float32:
+.globl syst_floatx80_to_float32
+syst_floatx80_to_float32:
 	fldt 4(%esp)
 	subl $4,%esp
 	fstps (%esp)
@@ -121,8 +121,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 2
-.globl _syst_floatx80_to_float64
-_syst_floatx80_to_float64:
+.globl syst_floatx80_to_float64
+syst_floatx80_to_float64:
 	fldt 4(%esp)
 	subl $8,%esp
 	fstpl (%esp)
@@ -136,8 +136,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 2
-.globl _syst_floatx80_round_to_int
-_syst_floatx80_round_to_int:
+.globl syst_floatx80_round_to_int
+syst_floatx80_round_to_int:
 	fldt 8(%esp)
 	frndint
 	movl 4(%esp),%eax
@@ -149,8 +149,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 2
-.globl _syst_floatx80_add
-_syst_floatx80_add:
+.globl syst_floatx80_add
+syst_floatx80_add:
 	fldt 8(%esp)
 	fldt 20(%esp)
 	faddp
@@ -163,8 +163,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 2
-.globl _syst_floatx80_sub
-_syst_floatx80_sub:
+.globl syst_floatx80_sub
+syst_floatx80_sub:
 	fldt 8(%esp)
 	fldt 20(%esp)
 	fsubrp
@@ -177,9 +177,9 @@
 -------------------------------------------------------------------------------
 */
 	.align 2
-.globl _syst_floatx80_mul
-_syst_floatx80_mul:
-	fldt 8(%esp)
+.globl syst_floatx80_mul
+ syst_floatx80_mul:
+ fldt 8(%esp)
 	fldt 20(%esp)
 	fmulp
 	movl 4(%esp),%eax
@@ -191,8 +191,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 2
-.globl _syst_floatx80_div
-_syst_floatx80_div:
+.globl syst_floatx80_div
+ syst_floatx80_div:
 	fldt 8(%esp)
 	fldt 20(%esp)
 	fdivrp
@@ -205,8 +205,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 2
-.globl _syst_floatx80_rem
-_syst_floatx80_rem:
+.globl syst_floatx80_rem
+ syst_floatx80_rem:
 	fldt 20(%esp)
 	fldt 8(%esp)
 floatx80_rem_loop:
@@ -224,8 +224,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 2
-.globl _syst_floatx80_sqrt
-_syst_floatx80_sqrt:
+.globl syst_floatx80_sqrt
+ syst_floatx80_sqrt:
 	fldt 8(%esp)
 	fsqrt
 	movl 4(%esp),%eax
@@ -237,8 +237,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 2
-.globl _syst_floatx80_eq
-_syst_floatx80_eq:
+.globl syst_floatx80_eq
+syst_floatx80_eq:
 	fldt 16(%esp)
 	fldt 4(%esp)
 	fucompp
@@ -254,8 +254,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 2
-.globl _syst_floatx80_le
-_syst_floatx80_le:
+.globl syst_floatx80_le
+syst_floatx80_le:
 	fldt 4(%esp)
 	fldt 16(%esp)
 	fcompp
@@ -270,8 +270,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 2
-.globl _syst_floatx80_lt
-_syst_floatx80_lt:
+.globl syst_floatx80_lt
+syst_floatx80_lt:
 	fldt 4(%esp)
 	fldt 16(%esp)
 	fcompp
@@ -286,8 +286,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 2
-.globl _syst_floatx80_eq_signaling
-_syst_floatx80_eq_signaling:
+.globl syst_floatx80_eq_signaling
+syst_floatx80_eq_signaling:
 	fldt 16(%esp)
 	fldt 4(%esp)
 	fcompp
@@ -303,8 +303,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 2
-.globl _syst_floatx80_le_quiet
-_syst_floatx80_le_quiet:
+.globl syst_floatx80_le_quiet
+syst_floatx80_le_quiet:
 	fldt 4(%esp)
 	fldt 16(%esp)
 	fucompp
@@ -319,8 +319,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 2
-.globl _syst_floatx80_lt_quiet
-_syst_floatx80_lt_quiet:
+.globl syst_floatx80_lt_quiet
+syst_floatx80_lt_quiet:
 	fldt 4(%esp)
 	fldt 16(%esp)
 	fucompp
diff -urN TestFloat-2a/testfloat/386-Win32-gcc/systmodes.S testfloat/testfloat/386-Win32-gcc/systmodes.S
--- TestFloat-2a/testfloat/386-Win32-gcc/systmodes.S	1998-12-14 07:08:56.000000000 +0100
+++ testfloat/testfloat/386-Win32-gcc/systmodes.S	2008-08-17 09:46:52.000000000 +0200
@@ -32,8 +32,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 4
-	.global _syst_float_set_rounding_mode
-_syst_float_set_rounding_mode:
+	.global syst_float_set_rounding_mode
+syst_float_set_rounding_mode:
 	movb 4(%esp),%al
 	andb $3,%al
 	shlw $10,%ax
@@ -57,8 +57,8 @@
 -------------------------------------------------------------------------------
 */
 	.align 4
-	.global _syst_float_set_rounding_precision
-_syst_float_set_rounding_precision:
+	.global syst_float_set_rounding_precision
+syst_float_set_rounding_precision:
 	movb 4(%esp),%al
 	movb $0,%ah
 	cmpb $32,%al
diff -urN TestFloat-2a/testfloat/arm-linux-gcc/Makefile testfloat/testfloat/arm-linux-gcc/Makefile
--- TestFloat-2a/testfloat/arm-linux-gcc/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/testfloat/arm-linux-gcc/Makefile	2013-12-02 19:08:39.825441591 +0100
@@ -0,0 +1,81 @@
+
+PROCESSOR_H = ../../processors/arm-gcc.h
+SOFTFLOAT_VERSION = bits32
+TARGET = arm-linux-gcc
+SOFTFLOAT_DIR = ../../softfloat/$(SOFTFLOAT_VERSION)/$(TARGET)
+
+OBJ = .o
+EXE = .exe
+INCLUDES = -I. -I.. -I$(SOFTFLOAT_DIR)
+COMPILE_ASM = $(CROSS_COMPILE)gcc -c -o $@
+COMPILE_C = $(CROSS_COMPILE)gcc -c -o $@ $(INCLUDES) -I- -O2 \
+	-mhard-float -mfloat-abi=hard -mfpu=vfp
+COMPILE_C_O0 = $(CROSS_COMPILE)gcc -c -o $@ $(INCLUDES) -I- -O1 \
+	-mhard-float -mfloat-abi=hard -mfpu=vfp
+	
+
+COMPILE_SLOWFLOAT_C = $(CROSS_COMPILE)gcc -c -o $@ $(INCLUDES) -I- -O3
+LINK = $(CROSS_COMPILE)gcc --static -o $@
+DISA = $(CROSS_COMPILE)objdump -lhda $@
+
+SOFTFLOAT_H = $(SOFTFLOAT_DIR)/softfloat.h
+SOFTFLOAT_OBJ = $(SOFTFLOAT_DIR)/softfloat$(OBJ)
+
+all: testsoftfloat$(EXE) testfloat$(EXE)
+
+milieu.h: $(PROCESSOR_H)
+	touch milieu.h
+
+fail$(OBJ): milieu.h ../fail.h
+	$(COMPILE_C) ../fail.c
+
+random$(OBJ): milieu.h ../random.h
+	$(COMPILE_C) ../random.c
+
+testCases$(OBJ): milieu.h ../fail.h ../random.h $(SOFTFLOAT_H) ../testCases.h ../testCases.c
+	$(COMPILE_C) ../testCases.c
+
+writeHex$(OBJ): milieu.h $(SOFTFLOAT_H) ../writeHex.h ../writeHex.c
+	$(COMPILE_C) ../writeHex.c
+
+testLoops$(OBJ): milieu.h $(SOFTFLOAT_H) ../testCases.h ../writeHex.h ../testLoops.h ../testLoops.c
+	$(COMPILE_C) ../testLoops.c
+
+slowfloat$(OBJ): milieu.h $(SOFTFLOAT_H) ../slowfloat.h ../slowfloat-32.c ../slowfloat-64.c ../slowfloat.c
+	$(COMPILE_SLOWFLOAT_C) ../slowfloat.c
+
+testsoftfloat$(OBJ): milieu.h ../fail.h $(SOFTFLOAT_H) ../testCases.h ../testLoops.h ../slowfloat.h ../testsoftfloat.c
+	$(COMPILE_C) ../testsoftfloat.c
+
+testsoftfloat$(EXE): fail$(OBJ) random$(OBJ) $(SOFTFLOAT_OBJ) testCases$(OBJ) writeHex$(OBJ) testLoops$(OBJ) slowfloat$(OBJ) testsoftfloat$(OBJ)
+	$(LINK) fail$(OBJ) random$(OBJ) $(SOFTFLOAT_OBJ) testCases$(OBJ) writeHex$(OBJ) testLoops$(OBJ) slowfloat$(OBJ) testsoftfloat$(OBJ)
+
+_systmodes$(OBJ): _systmodes.S
+	$(COMPILE_ASM) _systmodes.S
+
+systmodes$(OBJ): milieu.h ../systmodes.h systmodes.c
+	$(COMPILE_C) systmodes.c
+
+
+systflags$(OBJ): systflags.S
+	$(COMPILE_ASM) systflags.S
+
+systfloat$(OBJ): milieu.h ../systfloat.h systfloat.c
+	$(COMPILE_C_O0) systfloat.c
+
+_systfloat$(OBJ): _systfloat.S
+	$(COMPILE_ASM) _systfloat.S
+
+testFunction$(OBJ): milieu.h $(SOFTFLOAT_H) ../testCases.h ../testLoops.h ../systmodes.h ../systflags.h systfloat.h ../testFunction.h ../testFunction.c
+	$(COMPILE_C) ../testFunction.c
+
+testfloat$(OBJ): milieu.h ../fail.h $(SOFTFLOAT_H) ../testCases.h ../testLoops.h ../systflags.h ../testFunction.h ../testfloat.c
+	$(COMPILE_C) ../testfloat.c
+
+testfloat$(EXE): fail$(OBJ) random$(OBJ) $(SOFTFLOAT_OBJ) testCases$(OBJ) writeHex$(OBJ) testLoops$(OBJ) _systmodes$(OBJ) systmodes$(OBJ) _systmodes$(OBJ) systflags$(OBJ) systfloat$(OBJ) _systfloat$(OBJ) testFunction$(OBJ) testfloat$(OBJ)
+	$(LINK) fail$(OBJ) random$(OBJ) $(SOFTFLOAT_OBJ) testCases$(OBJ) writeHex$(OBJ) testLoops$(OBJ) systmodes$(OBJ) _systmodes$(OBJ) systflags$(OBJ) systfloat$(OBJ) _systfloat$(OBJ) testFunction$(OBJ) testfloat$(OBJ)
+	$(DISA) testfloat$(EXE) > testfloat.disa
+	
+clean: 
+	rm *.o
+	rm *.exe
diff -urN TestFloat-2a/testfloat/arm-linux-gcc/milieu.h testfloat/testfloat/arm-linux-gcc/milieu.h
--- TestFloat-2a/testfloat/arm-linux-gcc/milieu.h	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/testfloat/arm-linux-gcc/milieu.h	2008-08-17 09:46:52.000000000 +0200
@@ -0,0 +1,52 @@
+
+/*
+===============================================================================
+
+This C header file is part of TestFloat, Release 2a, a package of programs
+for testing the correctness of floating-point arithmetic complying to the
+IEC/IEEE Standard for Floating-Point.
+
+Written by John R. Hauser.  More information is available through the Web
+page `http://HTTP.CS.Berkeley.EDU/~jhauser/arithmetic/TestFloat.html'.
+
+THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort
+has been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT
+TIMES RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO
+PERSONS AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ANY
+AND ALL LOSSES, COSTS, OR OTHER PROBLEMS ARISING FROM ITS USE.
+
+Derivative works are acceptable, even for commercial purposes, so long as
+(1) they include prominent notice that the work is derivative, and (2) they
+include prominent notice akin to these four paragraphs for those parts of
+this code that are retained.
+
+===============================================================================
+*/
+
+/*
+-------------------------------------------------------------------------------
+Include common integer types and flags.
+-------------------------------------------------------------------------------
+*/
+#include "../../processors/386-gcc.h"
+
+/*
+-------------------------------------------------------------------------------
+If the `BITS64' macro is defined by the processor header file but the
+version of SoftFloat being tested is the 32-bit one (`bits32'), the `BITS64'
+macro must be undefined here.
+-------------------------------------------------------------------------------
+
+*/
+#undef BITS64
+
+/*
+-------------------------------------------------------------------------------
+Symbolic Boolean literals.
+-------------------------------------------------------------------------------
+*/
+enum {
+    FALSE = 0,
+    TRUE  = 1
+};
+
diff -urN TestFloat-2a/testfloat/arm-linux-gcc/systflags.S testfloat/testfloat/arm-linux-gcc/systflags.S
--- TestFloat-2a/testfloat/arm-linux-gcc/systflags.S	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/testfloat/arm-linux-gcc/systflags.S	2008-08-17 09:46:53.000000000 +0200
@@ -0,0 +1,44 @@
+
+/*
+===============================================================================
+
+This GNU assembler source file is part of TestFloat, Release 2a, a package
+of programs for testing the correctness of floating-point arithmetic
+complying to the IEC/IEEE Standard for Floating-Point.
+
+Written by John R. Hauser.  More information is available through the Web
+page `http://HTTP.CS.Berkeley.EDU/~jhauser/arithmetic/TestFloat.html'.
+
+THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort
+has been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT
+TIMES RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO
+PERSONS AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ANY
+AND ALL LOSSES, COSTS, OR OTHER PROBLEMS ARISING FROM ITS USE.
+
+Derivative works are acceptable, even for commercial purposes, so long as
+(1) they include prominent notice that the work is derivative, and (2) they
+include prominent notice akin to these four paragraphs for those parts of
+this code that are retained.
+
+===============================================================================
+*/
+
+	.text
+
+/*
+-------------------------------------------------------------------------------
+Clears the system's IEC/IEEE floating-point exception flags.  Returns the
+previous value of the flags.
+-------------------------------------------------------------------------------
+*/
+	.align 4
+.globl syst_float_flags_clear
+syst_float_flags_clear:
+        fmrx r0, fpscr
+        mov r1, r0
+        and r0, r0, #0x1F 
+        bic r1, r1, #0x1F00 @disable exceptions traps
+        bic r1, r1, #0x1F   @clear exceptions flags
+        fmxr fpscr, r1
+        mov pc,lr
+
diff -urN TestFloat-2a/testfloat/arm-linux-gcc/systfloat.c testfloat/testfloat/arm-linux-gcc/systfloat.c
--- TestFloat-2a/testfloat/arm-linux-gcc/systfloat.c	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/testfloat/arm-linux-gcc/systfloat.c	2008-08-17 09:46:53.000000000 +0200
@@ -0,0 +1,390 @@
+#include "milieu.h"
+#include "softfloat.h"
+#include "systfloat.h"
+
+/*
+float32 syst_int32_to_float32(int32 param)
+{
+	float32 res;
+	__asm__ __volatile__(
+		"fmsr	s14, %1\n"
+		"fsitos	s15, s14\n"
+		"fmrs	%0, s15\n"
+	: "=r" (res)
+	: "r" (param));		    
+
+	return res;  
+}
+
+*/
+
+
+void __syst_int32_to_float64(int32 param, float64 *res)
+{	
+	__asm__ __volatile__(
+		"fmsr	s15, %0\n"		
+		"fsitod	d7, s15\n"
+		"fmrrd	%0, %1, d7"
+	: "=r" (res->low),  "=r" (res->high)
+	: "r" (param));		    	
+}
+
+float64 syst_int32_to_float64(int32 param)
+{
+	float64 res;
+	__syst_int32_to_float64(param, &res);
+	return res;  	
+}
+
+
+/*
+int32 syst_float32_to_int32(float32 param)
+{	
+}
+*/
+
+/*
+int32 syst_float32_to_int32_round_to_zero(float32 param)
+{
+	return (int32)param;  
+}
+*/
+
+void __syst_float32_to_float64(float32 param, float64 *res)
+{	
+	__asm__ __volatile__(
+		"fmsr	s15, %0\n"
+		"fcvtds	d7, s15\n"
+		"fmrrd	%0, %1, d7"
+	: "=r" (res->low),  "=r" (res->high)
+	: "r" (param));		    
+}
+
+
+float64 syst_float32_to_float64(float32 param)
+{
+	float64 res;
+	__syst_float32_to_float64(param, &res);
+	return res;  
+}
+
+
+/*
+float32 syst_float32_add(float32 param1, float32 param2)
+{
+}
+*/
+
+/*
+float32 syst_float32_sub(float32 param1, float32 param2)
+{
+	return param1 - param2;
+}
+
+float32 syst_float32_mul(float32 param1, float32 param2)
+{
+	return param1 * param2;
+}
+
+float32 syst_float32_div(float32 param1, float32 param2)
+{
+	return param1 / param2;
+}
+*/
+
+/*
+float32 syst_float32_sqrt(float32 param)
+{
+	
+}
+*/
+
+/*
+flag syst_float32_eq(float32 param1, float32 param2)
+{
+	if (param1 == param2)
+		return 1;
+	else
+		return 0;
+}
+
+
+flag syst_float32_le(float32 param1, float32 param2)
+{
+	if (param1 <= param2)
+		return 1;
+	else
+		return 0;
+}
+
+flag syst_float32_lt(float32 param1, float32 param2)
+{
+	if (param1 < param2)
+		return 1;
+	else
+		return 0;
+}
+*/
+
+/*
+flag syst_float32_eq_signaling(float32 param1, float32 param2)
+{
+
+}
+
+
+flag syst_float32_le_quiet(float32 param1, float32 param2)
+{
+
+}
+
+flag syst_float32_lt_quiet(float32 param1, float32 param2)
+{
+
+}
+*/
+
+
+int32 syst_float64_to_int32(float64 param)
+{
+	float32 res;
+	__asm__ __volatile__(
+	"fmdrr d7, %1, %2\n"
+	"ftosid	s15, d7\n"
+	"fmrs	%0, s15\n"	
+	: "=r" (res) 
+	: "r" (param.low), "r" (param.high));		    
+	return res;
+
+}
+
+
+int32 syst_float64_to_int32_round_to_zero(float64 param)
+{	
+	float32 res;
+	__asm__ __volatile__(
+	"fmdrr d7, %1, %2\n"
+	"ftosizd	s15, d7\n"
+	"fmrs	%0, s15\n"	
+	: "=r" (res) 
+	: "r" (param.low), "r" (param.high));		    
+	return res;
+}
+
+
+float32 syst_float64_to_float32(float64 param)
+{
+	float32 res;
+	__asm__ __volatile__(
+	"fmdrr d7, %1, %2\n"
+	"fcvtsd	s15, d7\n"
+	"fmrs	%0, s15\n"	
+	: "=r" (res) 
+	: "r" (param.low), "r" (param.high));		    
+	return res;
+}
+
+
+void __syst_float64_add(float64 param1, float64 param2, float64 *res)
+{
+	float32 a, b;
+	__asm__ __volatile__(
+	"fmdrr d6, %2, %3\n"
+	"fmdrr	d7, %4, %5\n"
+	"faddd	d6, d6, d7\n"	
+	"fmrrd	%0, %1, d6\n"	
+	: "=r" (a),  "=r" (b)
+	:"r" (param1.low), "r" (param1.high), "r" (param2.low), "r" (param2.high));		    
+	res->low = a;
+	res->high = b;
+}
+
+
+float64 syst_float64_add(float64 param1, float64 param2)
+{
+	float64 res;
+	__syst_float64_add(param1, param2, &res);
+	return res;
+}
+
+void __syst_float64_sub(float64 param1, float64 param2, float64* res)
+{
+	float32 a, b;
+	__asm__ __volatile__(
+	"fmdrr d6, %2, %3\n"
+	"fmdrr	d7, %4, %5\n"
+	"fsubd	d6, d6, d7\n"	
+	"fmrrd	%0, %1, d6\n"	
+	: "=r"(a),  "=r"(b)
+	:"r" (param1.low), "r" (param1.high), "r" (param2.low), "r" (param2.high));		    
+	res->low = a;
+	res->high = b;	
+}
+
+float64 syst_float64_sub(float64 param1, float64 param2)
+{
+	float64 res;
+	__syst_float64_sub(param1, param2, &res);
+	return res;
+}
+
+
+void __syst_float64_mul(float64 param1, float64 param2, float64* res)
+{
+	float32 a, b;
+	__asm__ __volatile__(
+	"fmdrr d6, %2, %3\n"
+	"fmdrr	d7, %4, %5\n"
+	"fmuld	d5, d6, d7\n"	
+	"fmrrd	%0, %1, d5\n"	
+	:"=r"(a),  "=r"(b)
+	:"r" (param1.low), "r" (param1.high), "r" (param2.low), "r" (param2.high));		    
+	res->low = a;
+	res->high = b;	
+}
+
+float64 syst_float64_mul(float64 param1, float64 param2)
+{
+	float64 res;
+	__syst_float64_mul(param1, param2, &res);
+	return res;
+}
+
+void __syst_float64_div(float64 param1, float64 param2, float64* res)
+{
+	float32 a, b;
+	__asm__ __volatile__(
+	"fmdrr d6, %2, %3\n"
+	"fmdrr	d7, %4, %5\n"
+	"fdivd	d5, d6, d7\n"	
+	"fmrrd	%0, %1, d5\n"	
+	:"=r"(a),  "=r"(b)
+	:"r" (param1.low), "r" (param1.high), "r" (param2.low), "r" (param2.high));		    
+	res->low = a;
+	res->high = b;	
+}
+
+float64 syst_float64_div(float64 param1, float64 param2)
+{
+	float64 res;
+	__syst_float64_div(param1, param2, &res);
+	return res;
+}
+
+
+void __syst_float64_sqrt(float64 param, float64* res)
+{
+	float32 a, b;
+	__asm__ __volatile__(
+	"fmdrr d7, %2, %3\n"	
+	"fsqrtd	d6, d7\n"	
+	"fmrrd	%0, %1, d6\n"	
+	:"=r"(a), "=r"(b)
+	:"r" (param.low), "r" (param.high));		    
+	res->low = a;
+	res->high = b;	
+}
+
+float64 syst_float64_sqrt(float64 param1)
+{
+	float64 res;
+	__syst_float64_sqrt(param1, &res);
+	return res;
+}
+
+
+flag syst_float64_eq(float64 param1, float64  param2)
+{
+	flag res;
+	__asm__ __volatile__(
+	"fmdrr	d6, %1, %2\n"
+	"fmdrr	d7, %3, %4\n"
+	"fcmpd	d6, d7\n"
+	"fmstat		\n"
+	"movne	%0, #0\n"
+	"moveq	%0, #1\n"
+	: "=r" (res)
+	:"r" (param1.low), "r" (param1.high), "r" (param2.low), "r" (param2.high));		    
+	return res;	
+}
+
+flag syst_float64_le(float64 param1, float64 param2)
+{
+	flag res;
+	__asm__ __volatile__(
+	"fmdrr	d6, %1, %2\n"
+	"fmdrr	d7, %3, %4\n"
+	"fcmped	d6, d7\n"
+	"fmstat		\n"
+	"movls	%0, #1\n"
+	"movhi	%0, #0\n"
+	: "=r" (res)
+	:"r" (param1.low), "r" (param1.high), "r" (param2.low), "r" (param2.high));		    
+	return res;
+}
+
+flag syst_float64_lt(float64 param1, float64 param2)
+{
+	flag res;
+	__asm__ __volatile__(
+	"fmdrr	d6, %1, %2\n"
+	"fmdrr	d7, %3, %4\n"
+	"fcmped	d6, d7\n"
+	"fmstat		\n"
+	"movmi	%0, #1\n"
+	"movpl	%0, #0\n"
+	: "=r" (res)
+	:"r" (param1.low), "r" (param1.high), "r" (param2.low), "r" (param2.high));		    
+	return res;
+}
+
+
+flag syst_float64_eq_signaling(float64 param1, float64 param2)
+{
+	flag res;
+	__asm__ __volatile__(
+	"fmdrr	d6, %1, %2\n"
+	"fmdrr	d7, %3, %4\n"
+	"fcmped	d6, d7\n"
+	"fmstat		\n"
+	"movne	%0, #0\n"
+	"moveq	%0, #1\n"
+	: "=r" (res)
+	:"r" (param1.low), "r" (param1.high), "r" (param2.low), "r" (param2.high));		    
+	return res;	
+}
+
+flag syst_float64_le_quiet(float64 param1, float64 param2)
+{
+	flag res;
+	__asm__ __volatile__(
+	"fmdrr	d6, %1, %2\n"
+	"fmdrr	d7, %3, %4\n"
+	"fcmpd	d6, d7\n"
+	"fmstat		\n"
+	"movls	%0, #1\n"
+	"movhi	%0, #0\n"
+	: "=r" (res)
+	:"r" (param1.low), "r" (param1.high), "r" (param2.low), "r" (param2.high));		    
+	return res;
+}
+
+flag syst_float64_lt_quiet(float64 param1, float64 param2)
+{
+	flag res;
+	__asm__ __volatile__(
+	"fmdrr	d6, %1, %2\n"
+	"fmdrr	d7, %3, %4\n"
+	"fcmpd	d6, d7\n"
+	"fmstat		\n"
+	"movmi	%0, #1\n"
+	"movpl	%0, #0\n"
+	: "=r" (res)
+	:"r" (param1.low), "r" (param1.high), "r" (param2.low), "r" (param2.high));		    
+	return res;
+}
+
+
+
+
+
diff -urN TestFloat-2a/testfloat/arm-linux-gcc/systfloat.h testfloat/testfloat/arm-linux-gcc/systfloat.h
--- TestFloat-2a/testfloat/arm-linux-gcc/systfloat.h	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/testfloat/arm-linux-gcc/systfloat.h	2008-08-17 09:46:52.000000000 +0200
@@ -0,0 +1,188 @@
+
+/*
+===============================================================================
+
+This C header file is part of TestFloat, Release 2a, a package of programs
+for testing the correctness of floating-point arithmetic complying to the
+IEC/IEEE Standard for Floating-Point.
+
+Written by John R. Hauser.  More information is available through the Web
+page `http://HTTP.CS.Berkeley.EDU/~jhauser/arithmetic/TestFloat.html'.
+
+THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort
+has been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT
+TIMES RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO
+PERSONS AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ANY
+AND ALL LOSSES, COSTS, OR OTHER PROBLEMS ARISING FROM ITS USE.
+
+Derivative works are acceptable, even for commercial purposes, so long as
+(1) they include prominent notice that the work is derivative, and (2) they
+include prominent notice akin to these four paragraphs for those parts of
+this code that are retained.
+
+===============================================================================
+*/
+
+/*
+-------------------------------------------------------------------------------
+The following macros are defined to indicate that the corresponding
+functions exist.
+-------------------------------------------------------------------------------
+*/
+#define SYST_INT32_TO_FLOAT32
+#define SYST_INT32_TO_FLOAT64
+#define SYST_FLOAT32_TO_INT32
+#define SYST_FLOAT32_TO_INT32_ROUND_TO_ZERO
+#define SYST_FLOAT32_TO_FLOAT64
+#define SYST_FLOAT32_ADD
+#define SYST_FLOAT32_SUB
+#define SYST_FLOAT32_MUL
+#define SYST_FLOAT32_DIV
+#define SYST_FLOAT32_SQRT
+#define SYST_FLOAT32_EQ
+#define SYST_FLOAT32_LE
+#define SYST_FLOAT32_LT
+#define SYST_FLOAT32_EQ_SIGNALING
+#define SYST_FLOAT32_LE_QUIET
+#define SYST_FLOAT32_LT_QUIET
+#define SYST_FLOAT64_TO_INT32
+#define SYST_FLOAT64_TO_INT32_ROUND_TO_ZERO
+#define SYST_FLOAT64_TO_FLOAT32
+#define SYST_FLOAT64_ADD
+#define SYST_FLOAT64_SUB
+#define SYST_FLOAT64_MUL
+#define SYST_FLOAT64_DIV
+#define SYST_FLOAT64_SQRT
+#define SYST_FLOAT64_EQ
+#define SYST_FLOAT64_LE
+#define SYST_FLOAT64_LT
+#define SYST_FLOAT64_EQ_SIGNALING
+#define SYST_FLOAT64_LE_QUIET
+#define SYST_FLOAT64_LT_QUIET
+
+/*
+-------------------------------------------------------------------------------
+System function declarations.  (Some of these functions may not exist.)
+-------------------------------------------------------------------------------
+*/
+float32 syst_int32_to_float32( int32 );
+float64 syst_int32_to_float64( int32 );
+#ifdef FLOATX80
+floatx80 syst_int32_to_floatx80( int32 );
+#endif
+#ifdef FLOAT128
+float128 syst_int32_to_float128( int32 );
+#endif
+#ifdef BITS64
+float32 syst_int64_to_float32( int64 );
+float64 syst_int64_to_float64( int64 );
+#ifdef FLOATX80
+floatx80 syst_int64_to_floatx80( int64 );
+#endif
+#ifdef FLOAT128
+float128 syst_int64_to_float128( int64 );
+#endif
+#endif
+int32 syst_float32_to_int32( float32 );
+int32 syst_float32_to_int32_round_to_zero( float32 );
+#ifdef BITS64
+int64 syst_float32_to_int64( float32 );
+int64 syst_float32_to_int64_round_to_zero( float32 );
+#endif
+float64 syst_float32_to_float64( float32 );
+#ifdef FLOATX80
+floatx80 syst_float32_to_floatx80( float32 );
+#endif
+#ifdef FLOAT128
+float128 syst_float32_to_float128( float32 );
+#endif
+float32 syst_float32_add( float32, float32 );
+float32 syst_float32_sub( float32, float32 );
+float32 syst_float32_mul( float32, float32 );
+float32 syst_float32_div( float32, float32 );
+float32 syst_float32_rem( float32, float32 );
+float32 syst_float32_sqrt( float32 );
+flag syst_float32_eq( float32, float32 );
+flag syst_float32_le( float32, float32 );
+flag syst_float32_lt( float32, float32 );
+flag syst_float32_eq_signaling( float32, float32 );
+flag syst_float32_le_quiet( float32, float32 );
+flag syst_float32_lt_quiet( float32, float32 );
+int32 syst_float64_to_int32( float64 );
+int32 syst_float64_to_int32_round_to_zero( float64 );
+#ifdef BITS64
+int64 syst_float64_to_int64( float64 );
+int64 syst_float64_to_int64_round_to_zero( float64 );
+#endif
+float32 syst_float64_to_float32( float64 );
+#ifdef FLOATX80
+floatx80 syst_float64_to_floatx80( float64 );
+#endif
+#ifdef FLOAT128
+float128 syst_float64_to_float128( float64 );
+#endif
+float64 syst_float64_round_to_int( float64 );
+float64 syst_float64_add( float64, float64 );
+float64 syst_float64_sub( float64, float64 );
+float64 syst_float64_mul( float64, float64 );
+float64 syst_float64_div( float64, float64 );
+float64 syst_float64_rem( float64, float64 );
+float64 syst_float64_sqrt( float64 );
+flag syst_float64_eq( float64, float64 );
+flag syst_float64_le( float64, float64 );
+flag syst_float64_lt( float64, float64 );
+flag syst_float64_eq_signaling( float64, float64 );
+flag syst_float64_le_quiet( float64, float64 );
+flag syst_float64_lt_quiet( float64, float64 );
+#ifdef FLOATX80
+int32 syst_floatx80_to_int32( floatx80 );
+int32 syst_floatx80_to_int32_round_to_zero( floatx80 );
+#ifdef BITS64
+int64 syst_floatx80_to_int64( floatx80 );
+int64 syst_floatx80_to_int64_round_to_zero( floatx80 );
+#endif
+float32 syst_floatx80_to_float32( floatx80 );
+float64 syst_floatx80_to_float64( floatx80 );
+#ifdef FLOAT128
+float128 syst_floatx80_to_float128( floatx80 );
+#endif
+floatx80 syst_floatx80_round_to_int( floatx80 );
+floatx80 syst_floatx80_add( floatx80, floatx80 );
+floatx80 syst_floatx80_sub( floatx80, floatx80 );
+floatx80 syst_floatx80_mul( floatx80, floatx80 );
+floatx80 syst_floatx80_div( floatx80, floatx80 );
+floatx80 syst_floatx80_rem( floatx80, floatx80 );
+floatx80 syst_floatx80_sqrt( floatx80 );
+flag syst_floatx80_eq( floatx80, floatx80 );
+flag syst_floatx80_le( floatx80, floatx80 );
+flag syst_floatx80_lt( floatx80, floatx80 );
+flag syst_floatx80_eq_signaling( floatx80, floatx80 );
+flag syst_floatx80_le_quiet( floatx80, floatx80 );
+flag syst_floatx80_lt_quiet( floatx80, floatx80 );
+#endif
+#ifdef FLOAT128
+int32 syst_float128_to_int32( float128 );
+int32 syst_float128_to_int32_round_to_zero( float128 );
+#ifdef BITS64
+int64 syst_float128_to_int64( float128 );
+int64 syst_float128_to_int64_round_to_zero( float128 );
+#endif
+float32 syst_float128_to_float32( float128 );
+float64 syst_float128_to_float64( float128 );
+#ifdef FLOATX80
+floatx80 syst_float128_to_floatx80( float128 );
+#endif
+float128 syst_float128_round_to_int( float128 );
+float128 syst_float128_add( float128, float128 );
+float128 syst_float128_sub( float128, float128 );
+float128 syst_float128_mul( float128, float128 );
+float128 syst_float128_div( float128, float128 );
+float128 syst_float128_rem( float128, float128 );
+float128 syst_float128_sqrt( float128 );
+flag syst_float128_eq( float128, float128 );
+flag syst_float128_le( float128, float128 );
+flag syst_float128_lt( float128, float128 );
+flag syst_float128_eq_signaling( float128, float128 );
+flag syst_float128_le_quiet( float128, float128 );
+flag syst_float128_lt_quiet( float128, float128 );
+#endif
diff -urN TestFloat-2a/testfloat/arm-linux-gcc/_systfloat.S testfloat/testfloat/arm-linux-gcc/_systfloat.S
--- TestFloat-2a/testfloat/arm-linux-gcc/_systfloat.S	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/testfloat/arm-linux-gcc/_systfloat.S	2008-08-17 09:46:53.000000000 +0200
@@ -0,0 +1,183 @@
+
+/*
+===============================================================================
+
+This GNU assembler source file is part of TestFloat, Release 2a, a package
+of programs for testing the correctness of floating-point arithmetic
+complying to the IEC/IEEE Standard for Floating-Point.
+
+Written by John R. Hauser.  More information is available through the Web
+page `http://HTTP.CS.Berkeley.EDU/~jhauser/arithmetic/TestFloat.html'.
+
+THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort
+has been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT
+TIMES RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO
+PERSONS AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ANY
+AND ALL LOSSES, COSTS, OR OTHER PROBLEMS ARISING FROM ITS USE.
+
+Derivative works are acceptable, even for commercial purposes, so long as
+(1) they include prominent notice that the work is derivative, and (2) they
+include prominent notice akin to these four paragraphs for those parts of
+this code that are retained.
+
+===============================================================================
+*/
+	.text
+/*
+-------------------------------------------------------------------------------
+-------------------------------------------------------------------------------
+*/
+.align 4
+
+	.macro  DBGSTR1, str, arg
+
+	stmfd	sp!, {r0-r3, ip, lr}
+	mov	r1, \arg
+	add	r0, pc, #4
+	bl	printf
+	b	1f
+	.asciz  "@ \str\n"
+	.balign 4
+1:	ldmfd	sp!, {r0-r3, ip, lr}
+	.endm
+
+	.macro	VFPFMRX, rd, sysreg, cond
+	MRC\cond	p10, 7, \rd, \sysreg, cr0, 0	@ FMRX	\rd, \sysreg
+	.endm
+
+.globl syst_int32_to_float32
+syst_int32_to_float32:
+	fmsr	s14, r0
+	fsitos	s15, s14
+	fmrs	r0, s15
+	mov	pc, lr
+		
+.globl syst_float32_to_int32
+syst_float32_to_int32:
+        fmsr	s15, r0
+        ftosis	s15, s15
+        fmrs	r0, s15
+        mov	pc, lr
+
+.globl syst_float32_to_int32_round_to_zero
+syst_float32_to_int32_round_to_zero:
+        fmsr	s15, r0
+        ftosizs	s15, s15
+        fmrs	r0, s15
+        mov	pc, lr
+
+	
+.globl syst_float32_add
+syst_float32_add:
+        fmsr	s14, r0
+        fmsr	s15, r1
+        fadds	s13, s14, s15
+        fmrs	r0, s13
+        mov	pc, lr
+
+.globl syst_float32_sub
+syst_float32_sub:
+        fmsr	s14, r0
+        fmsr	s15, r1
+        fsubs	s13, s14, s15
+        fmrs	r0, s13
+        mov	pc, lr
+
+
+.globl syst_float32_mul
+syst_float32_mul:
+        fmsr	s14, r0
+        fmsr	s15, r1
+        fmuls	s13, s14, s15
+        fmrs	r0, s13
+        mov	pc, lr
+	
+.globl syst_float32_div
+syst_float32_div:
+        fmsr	s14, r0
+        fmsr	s15, r1
+        fdivs	s13, s14, s15
+        fmrs	r0, s13
+        mov	pc, lr
+
+		
+.globl syst_float32_sqrt
+syst_float32_sqrt:
+        fmsr	s13, r0
+        fsqrts	s14, s13
+        fmrs	r0, s14
+        mov	pc, lr
+
+
+.globl syst_float32_eq
+syst_float32_eq:
+        fmsr	s14, r0
+        fmsr	s15, r1
+        fcmps	s14, s15
+        fmstat
+        movne	r0, #0	
+        moveq	r0, #1	
+        mov	pc, lr
+
+.globl syst_float32_le
+syst_float32_le:
+        fmsr	s14, r0
+        fmsr	s15, r1
+        fcmpes	s14, s15
+        fmstat
+        mov	r0, #1	
+        movls	pc, lr
+        mov	r0, #0	
+        mov	pc, lr
+
+.globl syst_float32_lt
+syst_float32_lt:
+        fmsr	s14, r0
+        fmsr	s15, r1
+        fcmpes	s14, s15
+        fmstat
+        mov	r0, #1	
+        movmi	pc, lr
+        mov	r0, #0	
+        mov	pc, lr
+	
+	
+.globl syst_float32_eq_signaling
+syst_float32_eq_signaling:
+        fmsr	s14, r0
+        fmsr	s15, r1
+        fcmpes	s14, s15
+        fmstat
+        movne	r0, #0	
+        moveq	r0, #1	
+        mov	pc, lr
+
+.globl syst_float32_le_quiet
+syst_float32_le_quiet:
+        fmsr	s14, r0
+        fmsr	s15, r1
+        fcmps	s14, s15
+        fmstat
+        mov	r0, #1	
+        movls	pc, lr
+        mov	r0, #0	
+        mov	pc, lr
+
+.globl syst_float32_lt_quiet
+syst_float32_lt_quiet:
+        fmsr	s14, r0
+        fmsr	s15, r1
+        fcmps	s14, s15
+        fmstat
+        mov	r0, #1	
+        movmi	pc, lr
+        mov	r0, #0	
+        mov	pc, lr
+
+
+
+   
+/*
+-------------------------------------------------------------------------------
+-------------------------------------------------------------------------------
+*/
diff -urN TestFloat-2a/testfloat/arm-linux-gcc/systmodes.c testfloat/testfloat/arm-linux-gcc/systmodes.c
--- TestFloat-2a/testfloat/arm-linux-gcc/systmodes.c	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/testfloat/arm-linux-gcc/systmodes.c	2008-08-17 09:46:53.000000000 +0200
@@ -0,0 +1,33 @@
+#include "milieu.h"
+#include "systmodes.h"
+#include  <stdio.h>
+
+/*
+-------------------------------------------------------------------------------
+Sets the system's IEC/IEEE floating-point rounding mode.  Also disables all
+system exception traps.
+-------------------------------------------------------------------------------
+*/
+void _syst_float_set_rounding_mode(int32 roundingMode);
+
+void syst_float_set_rounding_mode(int8 roundingMode)
+{
+	int32 vfpRoundingMode = (int32)roundingMode;
+	_syst_float_set_rounding_mode(vfpRoundingMode<<22);	
+}
+
+
+/*
+-------------------------------------------------------------------------------
+Sets the rounding precision of subsequent extended double-precision
+operations.  The `precision' argument should be one of 0, 32, 64, or 80.
+If `precision' is 32, the rounding precision is set equivalent to single
+precision; else if `precision' is 64, the rounding precision is set
+equivalent to double precision; else the rounding precision is set to full
+extended double precision.
+-------------------------------------------------------------------------------
+*/
+
+void syst_float_set_rounding_precision(int8 roundingMode)
+{
+}
diff -urN TestFloat-2a/testfloat/arm-linux-gcc/_systmodes.S testfloat/testfloat/arm-linux-gcc/_systmodes.S
--- TestFloat-2a/testfloat/arm-linux-gcc/_systmodes.S	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/testfloat/arm-linux-gcc/_systmodes.S	2008-08-17 09:46:53.000000000 +0200
@@ -0,0 +1,50 @@
+
+/*
+===============================================================================
+
+This GNU assembler source file is part of TestFloat, Release 2a, a package
+of programs for testing the correctness of floating-point arithmetic
+complying to the IEC/IEEE Standard for Floating-Point.
+
+Written by John R. Hauser.  More information is available through the Web
+page `http://HTTP.CS.Berkeley.EDU/~jhauser/arithmetic/TestFloat.html'.
+
+THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort
+has been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT
+TIMES RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO
+PERSONS AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ANY
+AND ALL LOSSES, COSTS, OR OTHER PROBLEMS ARISING FROM ITS USE.
+
+Derivative works are acceptable, even for commercial purposes, so long as
+(1) they include prominent notice that the work is derivative, and (2) they
+include prominent notice akin to these four paragraphs for those parts of
+this code that are retained.
+
+===============================================================================
+*/
+
+	.text
+
+/*
+-------------------------------------------------------------------------------
+Sets the system's IEC/IEEE floating-point rounding mode.  Also disables all
+system exception traps.
+-------------------------------------------------------------------------------
+*/
+	.align 4
+.global _syst_float_set_rounding_mode
+_syst_float_set_rounding_mode:
+  fmrx r1, fpscr
+  bic r1, r1, #0x1F00 @disable exceptions traps
+  bic r1, r1, #0xc00000 @clear round mode 
+  orr r1, r1, r0  
+  fmxr fpscr, r1  
+  mov pc,lr
+
+.global syst_float_get_fpcsr
+syst_float_get_fpcsr:
+  fmrx r0, fpscr
+  mov pc,lr
+
+  	
+
diff -urN TestFloat-2a/testfloat/arm-linux-gcc/test.c testfloat/testfloat/arm-linux-gcc/test.c
--- TestFloat-2a/testfloat/arm-linux-gcc/test.c	1970-01-01 01:00:00.000000000 +0100
+++ testfloat/testfloat/arm-linux-gcc/test.c	2008-08-17 09:46:53.000000000 +0200
@@ -0,0 +1,23 @@
+
+typedef struct 
+	{	
+		int high, low;
+	} float64;
+
+float64 func(float64 a)
+{	
+	float64 b;
+	__asm__ __volatile__(
+	"fmdrr d13, %2, %3\n"	
+	"fmrrd %0, %1, d13\n"	
+	: "=r" (b.low), "=r"(b.high)
+	: "r" (a.low), "r" (a.high));		    
+
+}
+
+int main()
+{
+	float64 b  = {1,1};	
+	float64 a = func(a);
+}
+
diff -urN TestFloat-2a/testfloat/systmodes.h testfloat/testfloat/systmodes.h
--- TestFloat-2a/testfloat/systmodes.h	1998-12-10 00:53:06.000000000 +0100
+++ testfloat/testfloat/systmodes.h	2008-08-17 09:46:52.000000000 +0200
@@ -31,7 +31,10 @@
 -------------------------------------------------------------------------------
 */
 void syst_float_set_rounding_mode( int8 );
-
+/*
+Slava
+int32 syst_float_get_fpcsr(void);
+*/
 /*
 -------------------------------------------------------------------------------
 Target-specific function for setting the IEC/IEEE rounding precision of
diff -urN TestFloat-2a/testfloat/testfloat.c testfloat/testfloat/testfloat.c
--- TestFloat-2a/testfloat/testfloat.c	1998-12-15 04:24:18.000000000 +0100
+++ testfloat/testfloat/testfloat.c	2008-08-17 09:46:52.000000000 +0200
@@ -33,6 +33,7 @@
 #include "testLoops.h"
 #include "systflags.h"
 #include "testFunction.h"
+#include <fenv.h> /* assaf */
 
 static void catchSIGINT( int signalCode )
 {
@@ -246,7 +247,7 @@
         if ( forever ) {
             if ( ! roundingPrecision ) roundingPrecision = 80;
             if ( ! roundingMode ) roundingMode = ROUND_NEAREST_EVEN;
-        }
+        }	
         testFunction( functionCode, roundingPrecision, roundingMode );
     }
     else {
diff -urN TestFloat-2a/testfloat/testFunction.c testfloat/testfloat/testFunction.c
--- TestFloat-2a/testfloat/testFunction.c	1998-12-13 00:00:58.000000000 +0100
+++ testfloat/testfloat/testFunction.c	2008-08-17 09:46:52.000000000 +0200
@@ -1110,7 +1110,7 @@
      uint8 functionCode, int8 roundingPrecisionIn, int8 roundingModeIn )
 {
     int8 roundingPrecision, roundingMode;
-
+     
     roundingPrecision = 32;
     for (;;) {
         if ( ! functions[ functionCode ].roundingPrecision ) {
